---
title: '最短路径算法 Dijkstra'
date: 2023-10-16
type: Greed
---

**有向图、无负权重、有环**

![最短路径算法](/public/images/ds/graph/Dijkstra.drawio.png)

1. 先用一个表格记录 a 到其余点的距离，初始值是 a 到 a 的距离为 0，与其余点距离正无穷，从 a 点（起点）开始计算
2. 从 A 出发看可以直接到达的点距离为多少，接着获得距离更新表，有 B，C，D，如果比原来的值小，就更新。锁定 A 点，然后用 B，C，D 其中一个点为起点再出发找最近的点，如果有更短的路径就更新（已经确定的答案不碰，在所有未确定的路中找最短）
3. 当所有的点都锁死时候，就返回了。

```java

public static HashMap<Node, Integer> dijksttra(Node from) {
  HashMap<Node, Integer> distanceMap = new HashMap<>();
  distanceMap.put(from, 0);
  // 打过对号的点
  HashSet<Node> selectedNodes = new HashSet<>();
  Node minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes); // 找到最小距离的条点（未打钩
  while (minNode != null) {
    int distance = distanceMap.get(minNode);
    for (Edge edge : minNode.edges) {
      Node toNode = edge.to;
      if (!distanceMap.containsKey(toNode))
        distanceMap.put(toNode, distance + edge.weight);
      else
        distanceMap.put(edge.to, Math.min(distanceMap.get(toNode), distance + edge.weight));
    }
    selectedNodes.add(minNode);
    minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes); // 找到最小距离的条点（未打钩
  }

  return distanceMap;
}

public static Node getMinDistanceAndUnselectedNode(HashMap<Node, Integer> distanceMap, HashSet<Node> touchedNodes) {
  Node minNode = null;
  int minDistance = Integer.MAX_VALUE;
  for (Entry<Node, Integer> entry : distanceMap.entrySet()) {
    Node node = entry.getKey();
    int distance = entry.getValue();
    if (!touchedNodes.contains(node) && distance < minDistance) {
      minDistance = distance;
      minNode = node;
    }
  }
  return minNode;
}
```

<hr/>

| [Java ](https://github.com/ZhengKe996/DS/blob/main/src/graph/Dijkstra.java) |
| :-------------------------------------------------------------------------: |
