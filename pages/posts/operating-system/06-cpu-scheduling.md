---
title: 'CPU Scheduling(CPU调度)'
date: 2023-12-12
type: OperatingSystem
---

# CPU 调度程序

## 基本概念

- 多道程序设计的目的将 CPU 的利用率最大化。
- 多个进程同时存在于内存（并发），当一个进程暂不使用 CPU 时，系统调度另一个进程占用 CPU

## CPU-BURST DURATIONS

![DURATIONS](/public/images/os/06/CPU-BURST-DURATIONS.png)

- I/O bound（IO 密集型）指的是系统 CPU 效能相对硬盘和内存好很多，此时⼤部分 CPU 在等 io 的 读写，此时 CPU Loading 不⾼
- CPU bound（计算密集型）指的是系统的硬盘和内存的性能，相对于 CPU 的性能要好很多，此时 系统运作 CPU Loading 100% ，CPU 要读写，I/O 在很短时间完成，⽽ CPU 还有很多运算要处理， CPU Loading 很⾼。

⼤部分时间⽤来做计算和逻辑判断等 CPU 动作的程序称之为 CPU bound。

## CPU 调度程序

Whenever the CPU becomes **idle**, the operating system must select one of the processes in the **ready queue** to be executed. The selection process is carried out by the **CPU scheduler**.

## 抢占调度

- **非抢占调度（Nonpreemptive scheduling）** :一旦某个进程得到 CPU，就会一直占用到终止或等待状
  态。可以简单理解为：不会因为⼀个新的进程到来，⽽结束当前进程
- **抢占调度（Preemptive scheduling）** :系统会因为新的进程达到 CPU，⽽去选择⼀个最优的进⾏时间⽚的分配

# CPU 调度准则

## 调度算法性能的衡量

1. **CPU 利用率**：CPU 的忙碌程度
2. **响应时间**：从提交任务到第一次响应的时间
3. **等待时间**：进程累积在就绪队列中等待的时间
4. **周转时间**：从提交到完成的时间
5. **呑吐率**：每个时钟单位处理的任务数
6. **公平性**：以合理的方式让各个进程共享 CPU

## 调度性能指标

作业（job）= 进程（process）

假设作业 i 提交给系统的时刻是 ts，完成的时刻是`ti`，所需运行时间为 `tk`，那么：平均作业周转时间 T (i 是单个作业的周转时间)

![调度性能指标](/public/images/os/06/formula.png)

# 调度算法

## 先来先服务(FCFS)

First-Come, First-Served (FCFS) ;早期系统里，FCFS 意味着一个程序会**一直运行到结束**(尽管其中会出现等待 I/O 的情况) 如今，当一个程序阻塞时会让出 CPU

![FCFS](/public/images/os/06/FCFS-1.png)

**如果三个进程的到达顺序是: P1 , P2 , P3**

- 等待时间分别是: P1 = 0; P2 = 28; P3 = 37
- 平均等待时间是: (0 + 28 + 37)/3 = 22
- 平均作业周转时间是: (28 + 37 + 40)/3 = 35

**如果换一种执行顺序的话: P3 , P2 , P1**

![FCFS](/public/images/os/06/FCFS-2.png)

- 等待时间分别是: P1 = 12; P2 = 3; P3 = 0
- 平均等待时间是: (12 + 3 + 0)/3 = 5
- 平均周转时间是: (3 + 12 + 40)/3 = 18

### 优缺点

- 优点：简单易行
- 缺点：如果短作业处在长作业的后面将导致周围时间变长。想像在超市 里只买了一瓶矿泉水的你站在队伍的最后一位，有何感想？

## 时间片轮转(ROUND ROBIN)

- 每个进程都可以得到相同的 CPU 时间(CPU 时间片, time slice)，当时间片到达，进程将被剥夺 CPU 并加 入就绪队列的尾部 。
- **抢占式**调度算法
- n 个就绪队列中的进程和时间片 q =>

  - 每个进程获得 1/n 的 CPU 时间，大约是 q 个时间单位
  - 没有进程等待时间会超过 (n-1)q

| Process | CPU Time |
| :-----: | :------: |
|   P1    |    68    |
|   P2    |    53    |
|   P3    |    24    |
|   P4    |    8     |

**时间片=20**

![FCFS](/public/images/os/06/RR.png)

- **等待时间**：

  - P1=(68-20)+(112-88)+(145-132)=85
  - P2=(20-0)+(88-40)+(132-108)=92
  - P3=(40-0)+(108-60)=88
  - P4=(60-0)=60

- **平均等待时间** = (85+92+88+60)/4=81.25
- **平均等待时间** = (85+92+88+60)/4=81.25

### RR 算法分析

#### 时间片（time slice）取选

- 取值太小：进程切换开销显著增大(不能小于进程切换的时间)
- 取值较大：响应速度下降（取值无穷大将退化成 FCFS）
- 一般时间片的选取范围为 10ms~100ms
- 上下文切换的时间大概为 0.1ms~1ms （1%的 CPU 时间开销）

#### RR 算法优缺点

- 优点：公平算法
- 缺点：对长作业带来额外的切换开销

## 最短作业优先(SJF)

SJF(Shortest Job First)：下一次调度总是选择所需要 CPU 时间最短的那个作业（进程）。

这是一个**非抢占式**算法，也可以改成抢占式 SRTF

|     | 到达系统时间 | CPU Time |
| :-: | :----------: | :------: |
| P1  |      0       |    8     |
| P2  |      1       |    4     |
| P3  |      2       |    9     |
| P4  |      3       |    5     |

![SJF](/public/images/os/06/SJF.png)

### SJF/SRTF 算法分析

- 该算法总是将短进程移到长进程之前执行，因此平均等待时间最小，该算法被证明是最优的。
- 饥饿现象：长进程可能长时间无法获得 CPU
- 预测技术

  - 该算法需要事先知道进程所需的 CPU 时间(很难实现!)
  - 预测一个进程的 CPU 时间并非易事

### 优缺点

- 优点：优化了响应时间
- 缺点：难以预测作业 CPU 时间、不公平算法

## 优先级调度(PRIORITY)

- **优先级**通常为固定区间的数字，如[0, 10]：
- 数字大小与优先级高低的关系在不同系统中实现不一样，以 Linux 为例，0 为最高优先级。
- **调度策略**：下一次调度总是选择优先级最高的进程。
- SJF 是优先级调度的一个特例。
- 优先级调度可以是**抢占式**，也可以是**非抢占式**

![PRIORITY](/public/images/os/06/PRIORITY.png)

### 优先级的定义

- 静态优先级
  - 优先级保持不变，但会出现不公平(饥饿)现象
- 动态优先级（退化 Aging）
  - 根据进程占用 CPU 时间：当进程占有 CPU 时间愈长，则慢慢降低它的优先级；
  - 根据进程等待 CPU 时间：当进程在就绪队列中等待时间愈长，则慢慢提升它的优先级
