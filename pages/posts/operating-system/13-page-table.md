---
title: 'Page Table(页表)'
date: 2023-12-30
type: OperatingSystem
---

# 分页

![分页](/public/images/os/13/paging.png)

若逻辑地址长度为 `m bits`，页面大小：`2^n Bytes`

1. 页内位移占 `n bits`
2. 页号占 `m-n bits`

# PAGE TABLE(页表)

1. The operating system maintains a copy of the **page table** for **each process**.
2. This copy is used to **translate logical addresses to physical addresses**.
3. It is also used by the CPU dispatcher to define the **hardware page table** when a process is to be allocated the CPU.
4. Paging therefore **increases the context-switch time**.

# HARDWARE PAGE TABLE

1. **The page** table is **kept in main memory**, and a page table base register (PTBR) points to the page table.
2. Changing page tables requires changing only this one register, substantially reducing context-switch time.
3. With this scheme, **two memory accesses** are needed to access a byte (one for the page-table entry, one for the byte).

# TLB

TLB(Translation Look-aside Buffer) is a kind of small, fast-lookup hardware cache. It is used with page tables in the following way.

1. The TLB contains **only a few of the page-table entries**.
2. When a logical address is generated by the CPU, its page number is presented to the TLB.
3. **If the page number is found**, its frame number is **immediately** available and is used to access memory.
4. If **TLB miss**, a memory reference to the page table must be made.

![TLB](/public/images/os/13/paging-with-tlb.png)

## TLB HIT RATIO

1. The percentage of times that the page number of interest is found in the TLB is called the **hit ratio**.
2. An **80-percent hit ratio**, for example, means that we find the desired page number in the TLB 80 percent of the time. If it takes **100 nanoseconds** to access memory, please find the **effective memory-access time**.

`effective access time = 0.80 × 100 + 0.20 × 200 = 120 ns`

# 基于页的保护与共享

## 保护

1. 为了防止地址转换时出现异常，可在页表每个条目设置一个 `valid-invalid`比特位，用于表示该页的有效性。
2. 这个方法可以被轻松扩展以提供更好的保护级别，如'只读'、'读写'、'可执行'等

## 共享

![共享](/public/images/os/13/share.png)

# 多级页表

![多级页表](/public/images/os/13/multilevel-page-table.png)

一个 32 位地址采用两级页表的例子，页面大小是`4K Bytes`，第一级页表页的数量是 `1K` 个，每个页表页中包含的页面数量也是 `1K` 个。

## 页表大小

假设 CPU 是 32bits，采用的逻辑地址是 32bits，那么进程的逻辑地址空间大小为`2^32 Bytes`，即`4G Bytes`。

1. 若页面大小是`4K Bytes`，则一个进程最多被分成`1M`个页面，也就是说进程的页表最多有`1M`个页表项；
2. 若每个页表项占用`4 Bytes`，则每个页表最多占用`4M ytes`空间（1K 个**连续页框**）。

## 页表页

![页表页](/public/images/os/13/page-table-page.png)
