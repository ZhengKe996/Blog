---
title: orm gorm 📒
date: 2022-08-06
draft: true
lang: zh
duration: 15min
---

![orm](/public/images/orm-study/1-1.png)

## 什么是 orm?

ORM 全称是：Object Relational Mapping(对象关系映射)，其主要作用是在编程中，把面向对象的概念跟数据库中表的概念对应起来。举例来说就是，我定义一个对象，那就对应着一张表，这个对象的实例，就对应着表中的一条记录。针对 go 语言而言是映射成 struct，列可以映射成 struct 中的类型，存在的问题：数据库中的列具备很好的描述性，需要使用 struct 中的 tag。

对于数据来说，最重要最常用的是表：表中有列，orm 就是将一张表映射成一个类，表中的列映射成类中的一个类。

## orm 的优缺点

#### 优点：

1. 提高了开发效率。
2. 屏蔽 sql 细节。可以自动对实体 Entity 对象与数据库中的 Table 进行字段与属性的映射；不用直接 SQL 编码
3. 屏蔽各种数据库之间的差异

#### 缺点：

1. orm 会牺牲程序的执行效率和会固定思维模式
2. 太过依赖 orm 会导致 sql 理解不够
3. 对于固定的 orm 依赖过重，导致切换到其他的 orm 代价高

## 如何正确看待 orm 和 sql 之间的关系

1. sql 为主，orm 为辅
2. orm 主要目的是为了增加代码可维护性和开发效率

## gorm 连接 mysql

[官方文档](https://gorm.io/zh_CN/docs/connecting_to_the_database.html)

```go
	dsn := "用户名:密码@tcp(127.0.0.1:3306)/数据库名?charset=utf8mb4&parseTime=True&loc=Local"
	db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})
	if err != nil {
		panic(err)
	}
```

## gorm 打印日志

[官方文档](https://gorm.io/zh_CN/docs/logger.html)

```go
	newLogger := logger.New(
		log.New(os.Stdout, "\r\n", log.LstdFlags), // io writer（日志输出的目标，前缀和日志包含的内容——译者注）
		logger.Config{
			SlowThreshold:             time.Second,   // 慢 SQL 阈值
			LogLevel:                  logger.Silent, // 日志级别
			IgnoreRecordNotFoundError: true,          // 忽略ErrRecordNotFound（记录未找到）错误
			Colorful:                  false,         // 禁用彩色打印
		},
	)
  // ...
  db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{
		// 设置全局的logger
		Logger: newLogger,
	})
```

## gorm 声明模型

```go
  type Product struct {
    gorm.Model
    Code  string
    Price uint
  }
```

## gorm 生成表结构

```go
  err = db.AutoMigrate(&Product{})
```

![生成表结构](/public/images/orm-study/1-2.png)
![生成表结构](/public/images/orm-study/1-3.png)

## gorm 实现 CURD

#### 新增

```go
	db.Create(&Product{Code: "D42", Price: 100})
```

#### 查询

```go
	var product Product // 注意：传入的是指针
	db.First(&product, 1) // 根据整型主键查找
	db.First(&product, "code = ?", "D42") // 查找 code 字段值为 D42 的记录

  fmt.Println(product.Code) // D42
```

#### 新增

```go
	var product Product // 注意：需要与查询语句配合使用
	db.Model(&product).Update("Price", 200) // 将 product 的 price 更新为 200

  // Update - 更新多个字段
	db.Model(&product).Updates(Product{Price: 200, Code: "F42"}) // 仅更新非零值字段，需要传零值得设置模型类型
	db.Model(&product).Updates(map[string]interface{}{"Price": 200, "Code": "F42"})

```

#### 删除（非物理删除）

```go
	db.Delete(&product, 1) // 传入主键值

```
