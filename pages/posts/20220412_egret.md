---
title: Egret
date: 2022-04-12
draft: true
lang: zh
duration: 25min
---

## Egret 基本使用

### 项目结构

各文件夹功能说明

- .wing：包括 Egret 项目的任务配置文件和启动配置文件。
- wingProperties.json：Egret Wing 项目配置文件。
- bin-debug：项目调试时，所产生的文件存放于此目录。
- libs：库文件，包括 Egret 核心库和其他扩展库存放于此目录。
- resource：项目资源文件存放于此目录。
- scripts：项目构建和发布时需要用到的脚本文件存放在此目录。
- src：项目代码文件存放于此目录。
- template：项目模板文件存放于此目录。
- egretProperties.json：项目的配置文件。具体的配置说明可以参考：[EgretProperties 说明](http://developer.egret.com/cn/github/egret-docs/Engine2D/projectConfig/configFile/index.html)
- index.html：入口文件。具体的配置说明可以参考：[入口文件说明](http://developer.egret.com/cn/github/egret-docs/Engine2D/projectConfig/indexFile/index.html)
- manifest.json：网页清单文件。
- tsconfig.json：typescript 编译配置文件。

### 运行项目

```bash
egret run -a
```

### 绘制单色背景

```js
const bg: egret.Shape = new egret.Shape();
bg.graphics.beginFill(0x336699);
bg.graphics.drawRect(0, 0, this.stage.stageWidth, this.stage.stageHeight);
bg.graphics.endFill();
this.addChild(bg);
```

### 调整屏幕的适配模式

虽然显示出来了，但我们会发现一个现象，就是显示区域在浏览器中并没有占满。这是由于 Egret 项目建立后，默认的屏幕适配模式是不进行缩放的。

而 Egret 目前应用最广泛的是移动设备，通常需要的屏幕适配模式是整体显示。

Egret 提供了几种常规的适配模式，刚才所说的不进行缩放是一种，在 Egret 中表示为`showAll`。占满屏幕是另一种，为`fixedWidth`。`fixedWidth`模式下会保持原始宽高比缩放内容，缩放后应用程序内容在水平和垂直方向都填满播放器窗口，但只保持应用程序内容的原始宽度不变，高度可能会改变。 我们可以在`index.html`中修改适配模式，打开项目根目录下的`index.html`文件，找到`data-scale-mode`开始的代码行，将等号右边的内容修改为`fixedWidth`刷新页面，会发现，蓝色背景已经占满浏览器屏幕。

### 添加文字

```js
const tx: egret.TextField = new egret.TextField();
tx.text = "I'm Jack, I will use Egret create a fantasy mobile game!";
tx.size = 32;
this.addChild(tx);

tx.x = 20;
tx.y = 20;
tx.width = this.stage.stageWidth - 40;
```

### 响应用户操作

不管我们制作游戏还是某种应用，用户的交互都是必备的。

```js
tx.touchEnabled = true;
tx.addEventListener(egret.TouchEvent.TOUCH_TAP, this.touchHandler, this);
```

注意，第一行设置 touchEnabled 为 true，意即允许该显示对象响应 Touch 事件，这是 Egret 中特别需要注意的问题。因为所有的显示对象，默认都是不响应 Touch 事件的，这是基于性能考虑，因为打开对这种事件的响应，是对性能有不可忽略的影响的。 其中第二行代码新增一个方法的引用，这就是事件处理函数，我们需要事件处理函数中对用户操作做出对应的反应。 在 Main 类中，加入如下代码：

```js
private touchHandler( evt:egret.TouchEvent ):void{
    var tx:egret.TextField = evt.currentTarget;
    tx.textColor = 0x00ff00;
}
```

## Egret 项目配置

### 入口文件说明

`index.html` 为项目的入口文件，下面是 `body` 标签里的默认配置，您可以根据项目需求修改。

```html
<div
  style="margin: auto;width: 100%;height: 100%;"
  class="egret-player"
  data-entry-class="Main"
  data-orientation="auto"
  data-scale-mode="showAll"
  data-frame-rate="30"
  data-content-width="640"
  data-content-height="1136"
  data-multi-fingered="2"
  data-show-fps="false"
  data-show-log="false"
  data-show-fps-style="x:0,y:0,size:12,textColor:0xffffff,bgAlpha:0.9"
></div>
```

- data-entry-class：文件类名称。
- data-orientation：旋转模式。
- data-scale-mode：适配模式。
- data-frame-rate：帧频数。
- data-content-width：游戏内舞台的宽。
- data-content-height：游戏内舞台的高。
- data-multi-fingered：多指最大数量。
- data-show-fps：是否显示 fps 帧频信息。
- data-show-log：是否显示 egret.log 的输出信息。

在 `script` 标签内，有项目的启动参数,如下图所示

```js
egret.runEgret({
  renderMode: "webgl",
  audioType: 0,
  calculateCanvasScaleFactor: function (context) {
    var backingStore =
      context.backingStorePixelRatio ||
      context.webkitBackingStorePixelRatio ||
      context.mozBackingStorePixelRatio ||
      context.msBackingStorePixelRatio ||
      context.oBackingStorePixelRatio ||
      context.backingStorePixelRatio ||
      1;
    return (window.devicePixelRatio || 1) / backingStore;
  },
});
```

参数是一个对象，包括以下 3 个可选属性：

- “renderMode”: 引擎渲染模式，”canvas” 或者 “webgl”
- “audioType”: 使用的音频类型，0:默认，2:web audio，3:audio。
- “calculateCanvasScaleFactor”：屏幕的物理像素适配方法，使用默认的即可

### 入口文件模板

#### web

如果您项目的配置文件 `egretProperties.json` 里有 `template` 字段，那么发布 `Html5` 项目时，就会使用 `template/web/index.html` 来作为入口文件。
例如：

```json
{  "engineVersion": "5.2.9",  "compilerVersion": "5.2.9",  "template": {}, //该字段只要存在，  //就会使用 template/web/index.html 来作为入口文件。  ... }
```

#### runtime

发布原生项目的配置文件

### 项目配置文件说明

项目的根文件夹下有名为 `egretProperties.json` 的配置文件，引擎所涉及的配置均存储在此。

```json
{
  "engineVersion": "5.2.25",
  "compilerVersion": "5.2.25",
  "template": {},
  "target": {
    "current": "web"
  },
  "modules": [
    {
      "name": "egret"
    },
    {
      "name": "eui"
    },
    {
      "name": "assetsmanager"
    },
    {
      "name": "tween"
    },
    {
      "name": "promise"
    }
  ]
}
```

#### engineVersion 字段

项目当前用来运行游戏的 egret 引擎版本，

#### compilerVersion 字段

项目当前使用的 egret 命令行版本，比如执行 `build`,`publish` 等命令，每个版本略有不同

#### template 字段

如果存在该字段，在发布 `Html5` 项目时，会使用 `template/web/index.html` 来作为入口文件。

#### target 字段

执行 `build` 和 `publish` 命令时的目标类型。

- `web`：会编译成 Html5 项目
- `wxgame`：会编译成微信小游戏项目
- `bricks`：会编译 QQ 玩一玩项目
- `android`：会编译成安卓项目
- `iOS`：会编译成 iOS 项目

#### module 字段

定义项目中引用的所有库文件。
每一个库都是形如 `{ "name":"moduleName" , "path":"modulePath"}` 的配置信息。
`name` 字段是库名。`path` 字段是库文件存放路径，如果没有此字段，取默认值`${EGRET_DEFAULT}`

```js
  "modules": [
    {
      "name": "egret"
    },
    {
      "name": "eui"
    },
    {
      "name": "assetsmanager"
    },
    {
      "name": "tween"
    },
    {
      "name": "promise"
    }
  ]
```

**内置库**，主要包括:

- `egret` 引擎核心库
- `egret3d` 引擎 3D 库
- `assetsmanager` 资源管理模块
- `dragonBones` 龙骨
- `eui` UI 组件库
- `game` 游戏库
- `media` 多媒体库
- `socket` websocket 网络通讯库
- `tween` 缓动动画库

## Egret 绘制

### 显示对象

**1.基本概念**

“显示对象”，是可以在舞台上显示的对象。可以显示的对象，既包括可以直接看见的图形、文字、视频、图片等，也包括不能看见但真实存在的显示对象容器。在 Egret 中，视觉图形都是由显示对象和显示对象容器组成的。

DisplayObject 类是所有显示对象的父类，该类包含显示对象共有的属性与方法。

**2.可视属性**

可视属性用来定量描述显示对象在舞台中的显示状态，结合下图说明可视属性的含义。

![Egret](/public/images/egret/1-1.png)

如上图 1 所示，在 Egret 中定义舞台的坐标系

原点在屏幕左上角。

横轴使用 X 表示，向右为正。

纵轴使用 Y 表示，向下为正。

上图 1 中包含一个灰色的矩形，该矩形拥有一个“锚点”，Egret 使用该点的坐标表示矩形的坐标。通过 x 和 y 属性访问修改显示对象的坐标位置。示例代码如下：

```js
var shape: egret.Shape = new egret.Shape();
shape.x = 100;
shape.y = 20;
```

图 2 中展示了显示对象的缩放功能。缩放是指将显示对象的宽或高进行比例缩放。缩放功能通过 scaleX 和 scaleY 属性来实现。图中，对灰色的矩形宽高进行 0.5 倍缩放。示例代码如下：

```js
var shape: egret.Shape = new egret.Shape();
shape.scaleX = 0.5;
shape.scaleY = 0.5;
```

图 3 中展示了关于透明度的操作。显示对象的默认透明度为”1”，表示完全不透明，通过 alpha 属性访问修改透明度。alpha 取值范围为 0-1。示例代码如下：

```js
var shape: egret.Shape = new egret.Shape();
shape.alpha = 0.4;
```

图 4 中展示了显示对象的旋转操作，旋转角度可通过 rotation 属性访问修改。将图中的矩形旋转 30°，示例代码如下：

```js
var shape: egret.Shape = new egret.Shape();
shape.rotation = 30;
```

上图展示了显示对象中常用的可视属性，下面列表是显示对象的全部可视属性。

- alpha：透明度
- width：宽度
- height：高度
- rotation：旋转角度
- scaleX：横向缩放
- scaleY：纵向缩放
- skewX：横向斜切
- skewY：纵向斜切
- visible：是否可见
- x：X 轴坐标值
- y：Y 轴坐标值
- anchorOffsetX：对象绝对锚点 X
- anchorOffsetY：对象绝对锚点 Y

**3.核心显示类**

不同的内容对应不同的显示对象，Egret 中一共封装了 8 个显示相关的核心类，如下表。

![Egret](/public/images/egret/1-2.png)

**4.自定义显示对象类**

自定义显示对象类需要继承自 `DisplayObject`的具体子类，例如`Shape`或者`TextField`。

![Egret](/public/images/egret/1-3.png)

示例代码如下：

- 创建
  创建一个名称为 `MyGrid` 的类，并且继承自 `Shape` 。具体代码如下：

```js
class MyGrid extends egret.Shape{
    public constructor(){
        super();
        this.drawGrid();
    }
    private drawGrid(){
        this.graphics.beginFill( 0x0000ff );
        this.graphics.drawRect( 0, 0, 50,50 );
        this.graphics.endFill();
        this.graphics.beginFill( 0x0000ff );
        this.graphics.drawRect( 50, 50, 50, 50);
        this.graphics.endFill();
        this.graphics.beginFill( 0xff0000 );
        this.graphics.drawRect( 50, 0, 50,50 );
        this.graphics.endFill();
        this.graphics.beginFill( 0xff0000 );
        this.graphics.drawRect( 0, 50, 50,50 );
        this.graphics.endFill();
    }
}
```

在 `MyGrid` 中绘制了一个红蓝相间的 2\*2 格子，然后修改文档类`Main`，在文档类中创建并显示 `MyGrid`类的实例，具体代码如下：

```js
class Main extends egret.DisplayObjectContainer{
    public constructor(){
        super();
        this.addEventListener(egret.Event.ADDED_TO_STAGE,this.onAddToStage,this);
    }
    private onAddToStage(event:egret.Event){
        var _myGrid:MyGrid = new MyGrid();
        this.addChild( _myGrid );
    }
}
```

#### 显示容器

**1.基本概念**

所有的显示容器全部继承自 `DisplayObjectContainer` 类，该类继承自 `DisplayObject` 。也就是说，在 Egret 中，所有的容器都继承自 `DisplayObject`。

在 Egret 中,`DisplayObjectContainer` 封装了一些显示列表中常用的功能，将在后面文档中详细介绍。这些常用操作主要分为四类：

- 添加、删除子对象
- 访问子对象
- 检测子对象
- 设置叠放次序

> _在 Egret 中，显示对象被分为两大类：一种是可以包括其他显示对象的显示对象容器，简称为“容器”。另外一种是单纯的显示对象，除自身以外不能包括其他显示对象，简称“非容器对象”。_

**2.Sprite**

在 Egret 中，`Sprite`是一个常用矢量图的容器。

`Sprite`继承自 `DisplayObjectContainer`，同时添加了 Graphics 功能。

> _关于 Graphics 功能，会在矢量绘图部分进行详细讲解。_

**3.自定义容器**

自定义容器，可编写一个类，继承 `DisplayObjectContainer` 。如果要同时实现 Graphics 绘图功能，可继承 `Sprite`。

下面是一个自定义容器类的示例，该示例定义了一个`GridSprite`类。这个类默认绘制一个红蓝相间的格子。

```js
class GridSprite extends egret.Sprite
{
    public constructor()
    {
        super();
        this.drawGrid();
    }
    private drawGrid()
    {
        this.graphics.beginFill( 0x0000ff );
        this.graphics.drawRect( 0, 0, 50,50 );
        this.graphics.endFill();
        this.graphics.beginFill( 0x0000ff );
        this.graphics.drawRect( 50, 50, 50, 50);
        this.graphics.endFill();
        this.graphics.beginFill( 0xff0000 );
        this.graphics.drawRect( 50, 0, 50,50 );
        this.graphics.endFill();
        this.graphics.beginFill( 0xff0000 );
        this.graphics.drawRect( 0, 50, 50,50 );
        this.graphics.endFill();
    }
}
```

在文档类中，实例化 `GridSprite` 即可。

```js
var _myGrid: GridSprite = new GridSprite();
this.addChild(_myGrid);
```

#### 显示列表

显示列表用来管理和组织容器和非容器对象，当某个显示对象处在显示列表中，就可以在画面中看到该对象。当显示对象从显示列表中移除后，该对象从画面中消失。

在 Egret 内部维护着一个显示列表，开发者无需关心该列表是如何运行，只需对自己的显示对象进行相应的操作。下面以一个例子说明显示列表的工作方式。

表达下图所示的场景

![Egret](/public/images/egret/1-7.png)

在实际的操作中，可以把显示列表看成树状结构。

在这个树状结构中，处于最上层的是“舞台”。对应到程序中，是 `stage` 对象。舞台是 Egret 显示架构中最根本的显示容器。每个 Egret 应有且只有一个`stage`对象。舞台是这个显示树结构的根节点。

在舞台中，我们还拥有一个主容器。这个容器就是文档类所创建的容器。每一个 Egret 都会拥有一个文档类，这个文档类必须是一个显示对象容器。

在这个场景中，包含了一个场景背景，背景是由背景图和一颗大树组成的。另外两个元素分别是人物和草地。其树状结构如下图：

![Egret](/public/images/egret/1-8.png)

上面的树状结构图就是 Egret 的“显示列表”。

### 变换操作

#### 锚点操作

每个显示对象都包含一个锚点,锚点默认位于显示对象的左上角。

当设置一个显示对象的坐标位置时,会以锚点为参照改变显示对象的绘图位置。同时,锚点相对于显示对象的位置也是可以改变的。

```js
class AnchorTest extends egret.DisplayObjectContainer
{
    public constructor()
    {
        super();
        this.addEventListener(egret.Event.ADDED_TO_STAGE,this.onAddToStage,this);
    }
    private onAddToStage(event:egret.Event)
    {
        var shp:egret.Shape = new egret.Shape();
        shp.graphics.beginFill( 0x00ff00 );
        shp.graphics.drawRect( 0, 0, 100, 100 );
        shp.graphics.endFill();
        shp.x = 100;
        shp.y = 100;
        this.addChild( shp );
    }
}
```

上面的代码中，绘制了一个绿色的正方形，锚点默认在正方形的左上角位置，通过设置 `shp` 的 `x`、`y`属性来改变正方形的位置。

效果如下图：

<img src="/public/images/egret/1-9.png" width="500">

#### 修改锚点

可通过`anchorOffsetX`和 `anchorOffsetY`属性访问修改锚点的位置。

修改上例锚点的位置，让锚点居于正方形左上角 x 轴 50 像素的位置，代码如下：

```js
shp.anchorOffsetX = 50;
```

#### 本地坐标和舞台坐标

x 和 y 属性始终是指显示对象相对于其父显示对象坐标轴的 (0,0) 坐标的位置。因此，对于包含在 DisplayObjectContainer 实例内的 Shape 实例（如圆），如果将 Shape 对象的 x 和 y 属性设置为 0，会将圆放在 DisplayObjectContainer 的左上角，但该位置不一定是舞台的左上角。若要确定对象相对于全局舞台坐标的位置，可以使用任何显示对象的 globalToLocal() 方法将坐标从全局（相对于舞台）坐标转换为本地（相对于显示对象容器）坐标，如下所示：

```js
//创建一个空的 DisplayObjectContainer，把它的 x 和 y 坐标都改为
var container: egret.DisplayObjectContainer = new egret.DisplayObjectContainer();
container.x = 200;
container.y = 200;
this.addChild(container);
//画一个红色的圆，添加到 container 中
var circle: egret.Shape = new egret.Shape();
circle.graphics.beginFill(0xff0000);
circle.graphics.drawCircle(25, 25, 25);
circle.graphics.endFill();
container.addChild(circle);
//给圆增加点击事件
circle.touchEnabled = true;
circle.addEventListener(egret.TouchEvent.TOUCH_TAP, onClick, this);
function onClick(): void {
  //把舞台左上角的坐标(0,0)转换为 container 内部的坐标
  var targetPoint: egret.Point = container.globalToLocal(0, 0);
  //重新定位圆，可以看到圆形移到了屏幕的左上角
  circle.x = targetPoint.x;
  circle.y = targetPoint.y;
}
```

同样，也可以使用 DisplayObject 类的 localToGlobal() 方法将本地坐标转换为舞台坐标。

#### 斜切

斜切是对图像在 2D 空间进行的一种平行矩阵变形。

斜切可从两个方向进行控制，对 X 方向的斜切将导致矩形的底边在 X 方向发生相应的偏移。

<img src="/public/images/egret/1-10.png" width="400">

如上图所示，是对白鹭小鸟进行 X 方向斜切 10 所达到的结果。左边是未变形的原始图片，右边是变形后的图片。

```js
// 设定对象的X方向斜切
mySprite.skewX = 10;
```

同理，对 Y 方向的斜切将导致矩形的右侧边在 Y 方向发生相应的偏移。

<img src="/public/images/egret/1-11.png" width="400">

如上图所示，是对白鹭小鸟进行 Y 方向斜切 10 所达到的结果。

```js
// 设定对象的Y方向斜切
mySprite.skewY = 10;
```

### 添加与删除显示对象

在 Egret 中建立显示对象和渲染显示对象是两个过程。建立显示对象后，对象会处于内存中，但不会参与渲染过程，只有把显示对象放到显示列表后，显示对象才会参与渲染过程。如果想将某个显示对象从渲染过程中删除，只需要将其移除显示列表即可。

#### 添加显示对象到显示列表

当创建一个显示对象后，就可以将其添加到显示列表中，首先绘制一个 Sprite，这个 Sprite 是一个宽高为 100 的绿色正方形。

```js
var spr: egret.Sprite = new egret.Sprite();
spr.graphics.beginFill(0x00ff00);
spr.graphics.drawRect(0, 0, 100, 100);
spr.graphics.endFill();
```

上面的代码就是建立显示对象的过程，测试程序，在舞台中看不到任何内容。将 spr 添加到显示列表中，代码如下：

```js
this.addChild(spr);
```

添加这句代码之后，再次编译运行程序，浏览器中看到效果如图：

<img src="/public/images/egret/1-12.png" width="600">

代码中 `addChild()` 方法将 `spr` 添加到显示列表中。前面介绍过，显示列表是一个树状结构，这里 `spr` 的上一级就是 `this`，也就是文档类。文档类是 `stage` 舞台的第一个子对象。

下面是关于当前示例的层级示意图:

![Egret](/public/images/egret/1-13.png)

#### 删除显示对象

使用 `removeChild()` 方法可删除显示对象，代码如下：

```js
this.removeChild(spr);
```

执行删除操作与添加显示对象操作类似，将被删除的显示对象作为参数传递给 `removeChild` 方法。示例中 `spr` 就是被删除的显示对象，而 `this` 则是 `spr` 的父级。

#### 注意

**显示对象独立于显示列表**

虽然显示对象在运行时会被高频率的添加到显示列表或从中删除，但显示对象独立于显示列表。简单解释：当创建一个显示对象`Sprite`时，该对象拥有自己的坐标属性，旋转角度属性等。这些属性都是显示对象独立拥有的。一旦该显示对象被添加到显示列表之中，Egret 就会按照显示对象的状态进行显示。

**当用户将显示对象从显示列表中移除后，这些状态依然存在。将一个显示对象移除显示列表后，该对象并非在内存中被销毁。只是不让显示对象参与渲染而已。**

通过一段代码观察显示对象在容器中的操作与状态改变：

```js
//创建了一个类型为Sprite的显示对象
var spr: egret.Sprite = new egret.Sprite();
spr.graphics.beginFill(0x00ff00);
spr.graphics.drawRect(0, 0, 100, 100);
spr.graphics.endFill();
//该对象存在，被添加到显示列表中，在画面中显示
this.addChild(spr);
//该对象存在，但已被移除显示列表，画面上不显示
this.removeChild(spr);
//该对象存在，驻于内存中
```

### 深度管理

每一个容器都有深度管理功能，它就像排队一样。

每一个显示对象在其父级的容器中都拥有一个属于自己的深度值，而且这个值相对于同级显示对象是唯一的。深度值实际上就是一个显示对象的叠放次序。也可称为 _“z-次序”_。

深度是由每个容器的子对象列表所管理。每个容器都清楚自己拥有多少个子对象。可以通过容器的 `numChildren` 属性来获取当前容器的子对象数量。

#### 深度顺序

Egret 中容器的深度都是从 0 开始的，当第一个显示对象被添加到容器中时，它的深度值为 0。这个显示对象处于容器的最底层。当添加第二个显示对象的时候，它的深度值为 1，并且在第一个显示对象上方。如果两个显示对象发生了相交，那么可以从视觉上看到，第二个显示对象遮挡住第一个显示对象。

下面的示例中，创建了两个显示对象，并且让他们发生遮挡，依次查看显示对象的深度值关系。

```js
var spr1: egret.Sprite = new egret.Sprite();
spr1.graphics.beginFill(0xff0000);
spr1.graphics.drawRect(0, 0, 100, 100);
spr1.graphics.endFill();
this.addChild(spr1); // 深度 0
var spr2: egret.Sprite = new egret.Sprite();
spr2.graphics.beginFill(0x00ff00);
spr2.graphics.drawRect(0, 0, 80, 80);
spr2.graphics.endFill();
spr2.x = 50;
spr2.y = 50;
this.addChild(spr2); // 深度1
```

<img src="/public/images/egret/1-16.png" width="600">

#### 添加/删除指定深度的对象

使用的 `addChild()` 方法会默认按照当前子对象深度进行排序，从 0 开始，每次深度加 1，以此类推。

若要将某一个显示对象添加到一个指定深度的时候，需要使用 `addChildAt()` 方法。

![Egret](/public/images/egret/1-15.png)

`addChildAt()`具体使用方法如下：

```js
容器.addChildAt(显示对象, 深度值);
```

在下面的示例中，随机绘制四个颜色不同的正方形，将它们依次叠加排列，然后新建一个显示对象，并且放到深度为 1 的位置。

```js
var sprcon: egret.Sprite = new egret.Sprite();
this.addChild(sprcon);
sprcon.x = 10;
for (var i: number = 0; i < 4; i++) {
  var spr: egret.Sprite = new egret.Sprite();
  spr.graphics.beginFill(0xffffff * Math.random());
  spr.graphics.drawRect(0, 0, 100, 100);
  spr.graphics.endFill();
  spr.x = i * 20;
  sprcon.addChild(spr);
}
var sprNew: egret.Sprite = new egret.Sprite();
sprNew.graphics.beginFill(0xff0000);
sprNew.graphics.drawRect(0, 0, 300, 150);
sprNew.graphics.endFill();
sprNew.x = 10;
sprNew.y = 50;
sprcon.addChildAt(sprNew, 1);
```

<img src="/public/images/egret/1-17.png" width="600">

在删除显示对象时同样可以通过深度来进行控制。

可以使用 `容器.removeChild( 显示对象 )` 将一个显示对象移除显示列表，同样，还可以使用

`容器.removeChildAt( 深度值 )` 来删除一个指定深度的显示对象。

通过对上面示例代码的修改，将深度值为 2 的显示对象移除显示列表。

```js
var sprcon: egret.Sprite = new egret.Sprite();
this.addChild(sprcon);
sprcon.x = 10;
for (var i: number = 0; i < 4; i++) {
  var spr: egret.Sprite = new egret.Sprite();
  spr.graphics.beginFill(0xffffff * Math.random());
  spr.graphics.drawRect(0, 0, 100, 100);
  spr.graphics.endFill();
  spr.x = i * 20;
  sprcon.addChild(spr);
}
var sprNew: egret.Sprite = new egret.Sprite();
sprNew.graphics.beginFill(0xff0000);
sprNew.graphics.drawRect(0, 0, 300, 150);
sprNew.graphics.endFill();
sprNew.x = 10;
sprNew.y = 50;
sprcon.addChildAt(sprNew, 1);
sprcon.removeChildAt(2);
```

<img src="/public/images/egret/1-18.png" width="600">

若要一次性将一个容器内的所有子对象全部删除。

Egret 提供了一个方便快捷的方法，使用 `removeChildren()` 方法可以将当前容器内的所有子对象全部移除显示列表。

使用方法如下：

```js
容器.removeChildren();
```

依然使用上面的示例，继续在后面编写代码：

```js
sprcon.removeChildren();
```

编译并运行，舞台 sprcon 内没有任何显示对象显示。

#### 交换不同深度对象

Egret 为开发者提供了两个方法实现交换不同对象深度的功能。一个是 `swapChildren()` 方法，另外一个是 `swapChildrenAt()` 方法。

具体使用方法如下：

```js
容器.swapChildren(显示对象, 显示对象);
容器.swapChildrenAt(深度值, 深度值);
```

下面示例中，创建一个 sprcon 容器，并向其中绘制两个颜色不同的方块。然后分别使用上面两个方法互换两个方块的深度值。

```js
var sprcon: egret.Sprite = new egret.Sprite();
this.addChild(sprcon);
sprcon.x = 10;
var spr1: egret.Sprite = new egret.Sprite();
spr1.graphics.beginFill(0xff0000);
spr1.graphics.drawRect(0, 0, 100, 100);
spr1.graphics.endFill();
spr1.x = 50;
sprcon.addChild(spr1);
var spr2: egret.Sprite = new egret.Sprite();
spr2.graphics.beginFill(0x00ff00);
spr2.graphics.drawRect(0, 0, 100, 100);
spr2.graphics.endFill();
spr2.x = 100;
spr2.y = 50;
sprcon.addChild(spr2);
```

使用**第一种方法**进行两个方块的深度互换：

sprcon.swapChildren( spr1, spr2 );

使用**第二种方法**进行两个方块的深度互换：

sprcon.swapChildrenAt( 0, 1 );

#### 重设子对象深度

当一个显示对象添加到显示列表中后，可以手动重设这个显示对象的深度。

实现显示对象深度重置的方法是 `setChildIndex()` ，使用方法如下：

```js
容器.setChildIndex(显示对象, 新的深度值);
```

示例代码如下：

```js
var sprcon: egret.Sprite = new egret.Sprite();
this.addChild(sprcon);
sprcon.x = 10;
var spr1: egret.Sprite = new egret.Sprite();
spr1.graphics.beginFill(0xff0000);
spr1.graphics.drawRect(0, 0, 100, 100);
spr1.graphics.endFill();
spr1.x = 50;
sprcon.addChild(spr1);
var spr2: egret.Sprite = new egret.Sprite();
spr2.graphics.beginFill(0x00ff00);
spr2.graphics.drawRect(0, 0, 100, 100);
spr2.graphics.endFill();
spr2.x = 100;
spr2.y = 50;
sprcon.addChild(spr2);
sprcon.setChildIndex(spr1, 1);
```

上面这段代码中默认是绿色的方块遮盖在红色方块上方的，通过对 spr1（红色方块）的深度重置（重置为 1）将其放置于绿色方块上方。

#### 访问容器子对象

Egret 提供两种访问容器子对象的方法: `getChildAt()` 和 `getChildByName()` 方法。

具体使用方法如下：

```js
容器.getChildAt( 深度值 );`
`容器.getChildByName( 显示对象 )
```

下面示例代码中，向一个容器中存放了两个方块，通过深度来获取其中一个方块，并调整它的透明度。

```js
var sprcon: egret.Sprite = new egret.Sprite();
this.addChild(sprcon);
sprcon.x = 10;
var spr1: egret.Sprite = new egret.Sprite();
spr1.graphics.beginFill(0xff0000);
spr1.graphics.drawRect(0, 0, 100, 100);
spr1.graphics.endFill();
spr1.x = 50;
spr1.name = "sprite1";
sprcon.addChild(spr1);
var spr2: egret.Sprite = new egret.Sprite();
spr2.graphics.beginFill(0x00ff00);
spr2.graphics.drawRect(0, 0, 100, 100);
spr2.graphics.endFill();
spr2.x = 100;
spr2.y = 50;
spr2.name = "sprite2";
sprcon.addChild(spr2);
var _spr: egret.DisplayObject = sprcon.getChildAt(1);
_spr.alpha = 0.5;
```

下面示例代码中，通过显示对象的 `name` 获取其中一个方块，并调整它的透明度。

```js
var sprcon: egret.Sprite = new egret.Sprite();
this.addChild(sprcon);
sprcon.x = 10;
var spr1: egret.Sprite = new egret.Sprite();
spr1.graphics.beginFill(0xff0000);
spr1.graphics.drawRect(0, 0, 100, 100);
spr1.graphics.endFill();
spr1.x = 50;
spr1.name = "sprite1";
sprcon.addChild(spr1);
var spr2: egret.Sprite = new egret.Sprite();
spr2.graphics.beginFill(0x00ff00);
spr2.graphics.drawRect(0, 0, 100, 100);
spr2.graphics.endFill();
spr2.x = 100;
spr2.y = 50;
spr2.name = "sprite2";
sprcon.addChild(spr2);
var _spr: egret.DisplayObject = sprcon.getChildByName("sprite2");
_spr.alpha = 0.5;
```

- **两种获取方式对比**

  通过深度值和 `name` 属性获取子对象的作用是相同的，**但 Egret 在内部的实现原理却大大不同。**

  使用深度值获取子对象时，Egret 会根据当前容器的显示列表查找指定深度的显示对象，并作为返回值返回给用户。这种检索方式是快速的，不需要进行大量运算。

  通过 name 属性来获取子对象，Egret 内部首先会对当前容器的所有子对象进行编译，同时匹配相同的 `name` 属性值，当发现相同 `name`属性的时候，则将该子对象作为返回值返回给用户。虽然在 Egret 内部进行了相关算法优化，但还是在消耗了一些性能。

  **因此推荐使用第一种方法，通过深度值来获取子对象。**

zindex

重设子对象深度有 2 种方法:[使用 setChildIndex ](http://developer.egret.com/cn/github/egret-docs/Engine2D/displayObject/depthManagement/index.html#4.重设子对象深度)和使用 zIndex.

从 Egret 5.2.24 版本开始，`DisplayObject` 中新增加了一个 `zIndex` 属性，可以设置对象的 Z 轴顺序。该值越大，越靠近顶部。

在 PC 的 Chrome 浏览器和安卓系统中，`zIndex` 的效率比 `setChildIndex` 高很多。极限测试时可以达到 10 倍以上。

在 iOS 系统中，两种方式的效率基本一致，没有很大区别，这跟系统浏览器的内核有关。

**注意，要给一个对象使用 zIndex，包含此显示对象的 DisplayObjectContainer 对象一定要设置 sortableChildren = true，开启排序功能，否则设置 zIndex 是无效的**

```js
let container = new egret.Sprite();
container.sortableChildren = true; //注意，一定要设置为true
this.addChild(container);
let texture: egret.Texture = RES.getRes("bird_png");
let b1 = new egret.Bitmap();
b1.texture = texture;
b1.x = 100;
this.addChild(b1);
let b2 = new egret.Bitmap();
b2.texture = texture;
b2.x = 270;
this.addChild(b2);
let b3 = new egret.Bitmap();
b3.texture = texture;
b3.x = 440;
this.addChild(b3);
b2.zIndex = 3; //将第二个图片设置到顶部
```

### 矢量绘图

Egret 中封装了 `Graphics` 类实现矢量绘图功能，可以绘制矩形、圆形、直线、曲线、圆弧等。下面介绍了矢量绘图功能的基本用法和若干高级用法。

#### 绘制矩形

`Graphics` 类中封装的绘图方法不能直接使用，而需要在显示对象中使用。一些显示对象（如 `Shape` 和 `Sprite` ）中已经包含了绘图方法，因此可以在显示对象中直接调用这些方法进行绘图。

下面代码以 `Shape` 对象为例，绘制矩形的：

```js
class GraphicsTest extends egret.DisplayObjectContainer
{
    public constructor()
    {
        super();
        this.addEventListener(egret.Event.ADDED_TO_STAGE,this.onAddToStage,this);
    }
    private onAddToStage(event:egret.Event)
    {
        var shp:egret.Shape = new egret.Shape();
        shp.graphics.beginFill( 0xff0000, 1);
        shp.graphics.drawRect( 0, 0, 100, 200 );
        shp.graphics.endFill();
        this.addChild( shp );
    }
}
```

调用 `beginFill()` 方法设置矩形的填充颜色，这里将填充颜色设置为红色（颜色值 0xff0000），同时将`alpha`设置为 1，表示完全不透明。

调用 `drawRect()` 方法设置矩形的位置和大小，前两个参数分别为矩形左上角的 X、Y 轴坐标（相对于 `shp` 的锚点计算），后两个参数分别为矩形的宽和高，这里在 (0, 0) 点绘制了一个 100\*200 的矩形。

调用 `endFill()` 方法结束当前绘制操作。

#### 绘制圆形

绘制圆形的方法与绘制矩形类似，只需将 `drawRect()` 方法改为 `drawCircle()` 方法。

```
drawCircle( x:number, y:number, radius:number): void
```

`drawCircle()` 方法接受三个参数，第一个参数为圆心的 X 轴坐标，第二个参数为圆心的 Y 轴坐标，第三个参数为半径。

注意：圆心的 X 轴和 Y 轴位置是相对于 `Shape` 对象的锚点计算的.

下面代码示例绘制了一个半径为 50 像素的圆形：

```js
class GraphicsTest extends egret.DisplayObjectContainer
{
    public constructor()
    {
        super();
        this.addEventListener(egret.Event.ADDED_TO_STAGE,this.onAddToStage,this);
    }
    private onAddToStage(event:egret.Event)
    {
        var shp:egret.Shape = new egret.Shape();
        shp.x = 100;
        shp.y = 100;
        shp.graphics.lineStyle( 10, 0x00ff00 );
        shp.graphics.beginFill( 0xff0000, 1);
        shp.graphics.drawCircle( 0, 0, 50 );
        shp.graphics.endFill();
        this.addChild( shp );
    }
}
```

#### 绘制直线

使用 Graphics 绘制直线需要使用两个方法: `moveTo()` 和 `lineTo()`，它们输入参数是一对坐标值。`moveTo()` 负责绘制直线的起始点，`lineTo()` 负责绘制直线的终点。

```js
moveTo( x:number, y:number): void
lineTo( x:number, y:number): void
```

在绘图直线前，需要先制定线条的样式，设置 `lineStyle()` 方法：

```js
shp.graphics.lineStyle(2, 0x00ff00);
```

然后使用 `moveTo()` 来设定线条的起始点，使用 `lineTo()` 来设定线条的终点。完整代码如下：

```js
class GraphicsTest extends egret.DisplayObjectContainer
{
    public constructor()
    {
        super();
        this.addEventListener(egret.Event.ADDED_TO_STAGE,this.onAddToStage,this);
    }
    private onAddToStage(event:egret.Event)
    {
        var shp:egret.Shape = new egret.Shape();
        shp.graphics.lineStyle( 2, 0x00ff00 );
        shp.graphics.moveTo( 10,10 );
        shp.graphics.lineTo( 100, 20 );
        shp.graphics.endFill();
        this.addChild( shp );
    }
}
```

也可以连续绘制多条首尾相接的直线，形成一条折线，代码如下：

```js
var shp: egret.Shape = new egret.Shape();
shp.graphics.lineStyle(2, 0x00ff00);
shp.graphics.moveTo(68, 84);
shp.graphics.lineTo(167, 76);
shp.graphics.lineTo(221, 118);
shp.graphics.lineTo(290, 162);
shp.graphics.lineTo(297, 228);
shp.graphics.lineTo(412, 250);
shp.graphics.lineTo(443, 174);
shp.graphics.endFill();
this.addChild(shp);
```

绘制折线时，无需多次使用 `moveTo()` 方法，连续使用 `lineTo()` 方法即可。

### 遮罩

遮罩的作用是指定一个显示对象的可见区域，所有显示对象都具备遮罩功能。

#### 矩形遮罩

矩形遮罩，即显示对象的可见区域是方形显示区域而非不规则显示区域。

用法为：将一个矩形对象赋值给显示对象的 `mask` 属性。

```js
shp.mask = new egret.Rectangle(20, 20, 30, 50);
```

如果 `rect` 发生变化，需要重新将 `rect` 赋值给 `shp.mask`。

下面示例中绘制了两个 `Shape` 对象，对其中一个 `Shape` 使用矩形遮罩，另外一个 `Shape` 当做参考。代码如下：

```js
class Test extends egret.DisplayObjectContainer
{
    public constructor()
    {
        super();
        this.addEventListener(egret.Event.ADDED_TO_STAGE,this.onAddToStage,this);
    }
    private onAddToStage(event:egret.Event)
    {
        var shp:egret.Shape = new egret.Shape();
        shp.graphics.beginFill( 0xff0000 );
        shp.graphics.drawRect( 0,0,100,100);
        shp.graphics.endFill();
        this.addChild( shp );
        var shp2:egret.Shape = new egret.Shape();
        shp2.graphics.beginFill( 0x00ff00 );
        shp2.graphics.drawCircle( 0,0, 20);
        shp2.graphics.endFill();
        this.addChild( shp2 );
        shp2.x = 20;
        shp2.y = 20;
    }
}
```

现在对 `shp` 添加遮罩，具体代码如下：

```js
var rect: egret.Rectangle = new egret.Rectangle(20, 20, 30, 50);
shp.mask = rect;
```

可以看到，红色的正方形添加了遮罩后只显示了(20,20,30,50)这部分的图像。而未添加遮罩的绿色圆形依然显示完整。

#### 显示对象遮罩

显示对象遮罩，即显示对象的可见区域由另一个显示对象确定，可实现不规则遮罩。

用法为：将被遮罩显示对象的 `mask` 属性设置为遮罩对象：

```js
//将maskSprite设置为mySprite的遮罩
mySprite.mask = maskSprite;
```

被遮罩的显示对象的显示区域，在用作遮罩的显示对象的全部不透明区域之内。例如，下面的代码创建一个包含 100 x 100 像素的红色正方形的 `Shape` 实例和一个包含半径为 25 个像素的蓝色圆的 `Sprite` 实例，它被设置为正方形的遮罩。正方形的显示区域，是由圆的不透明区域覆盖的那一部分。

```js
//画一个红色的正方形
var square: egret.Shape = new egret.Shape();
square.graphics.beginFill(0xff0000);
square.graphics.drawRect(0, 0, 100, 100);
square.graphics.endFill();
this.addChild(square);
//画一个蓝色的圆形
var circle: egret.Shape = new egret.Shape();
circle.graphics.beginFill(0x0000ff);
circle.graphics.drawCircle(25, 25, 25);
circle.graphics.endFill();
this.addChild(circle);
square.mask = circle;
```

用作遮罩的显示对象可设置动画、动态调整大小。遮罩显示对象不一定需要添加到显示列表中。但是，如果希望在缩放舞台时也缩放遮罩对象，或者如果希望支持用户与遮罩对象的交互（如调整大小），则必须将遮罩对象添加到显示列表中。

通过将 `mask` 属性设置为 `null` 可以删除遮罩：

```
mySprite.mask = null;
```

不能使用一个遮罩对象来遮罩另一个遮罩对象。

显示对象作为遮罩，无需像矩形遮罩那样重复赋值 `mask`，但是 `mask` 必须是显示列表里的元素。

### 碰撞检测

Lol

#### 矩形碰撞检测

碰撞检测，判断显示对象是否与一点相交。

矩形碰撞检测，是判断显示对象的包围盒是否与一点相交。

Egret 提供 `hitTestPoint()` 方法进行碰撞检测，矩形碰撞检测的用法为：

```js
var isHit:boolean = shp.hitTestPoint( x: number, y:number );
```

`shp` 是待检测的显示对象，(x, y)是待检测的点的位置。如果发生碰撞，则方法返回 `true`,如果没有发生碰撞，则返回 `false`。

- 示例代码 1：

```js
class HitTest extends egret.DisplayObjectContainer
{
   public constructor()
   {
       super();
       this.addEventListener(egret.Event.ADDED_TO_STAGE,this.onAddToStage,this);
   }
   private onAddToStage(event:egret.Event)
   {
       this.drawText();
       var shp:egret.Shape = new egret.Shape();
       shp.graphics.beginFill( 0xff0000 );
       shp.graphics.drawRect( 0,0,100,100);
       shp.graphics.endFill();
       shp.width = 100;
       shp.height = 100;
       this.addChild( shp );
       var isHit:boolean = shp.hitTestPoint( 10, 10 );
       this.infoText.text = "isHit: " + isHit;
   }
   private infoText:egret.TextField;
   private drawText()
   {
       this.infoText = new egret.TextField();
       this.infoText.y = 200;
       this.infoText.text = "isHit";
       this.addChild( this.infoText );
   }
}
```

- 示例代码 2：

```js
class HitTest extends egret.DisplayObjectContainer
{
   public constructor()
   {
       super();
       this.addEventListener(egret.Event.ADDED_TO_STAGE,this.onAddToStage,this);
   }
   private onAddToStage(event:egret.Event)
   {
       this.drawText();
       var shp:egret.Shape = new egret.Shape();
       shp.graphics.beginFill( 0xff0000 );
       shp.graphics.drawCircle( 0, 0, 20);
       shp.graphics.endFill();
       shp.width = 100;
       shp.height = 100;
       this.addChild( shp );
       var isHit:boolean = shp.hitTestPoint( 25, 25 );
       this.infoText.text = "isHit: " + isHit;
   }
   private infoText:egret.TextField;
   private drawText()
   {
       this.infoText = new egret.TextField();
       this.infoText.y = 200;
       this.infoText.text = "isHit: ";
       this.addChild( this.infoText );
   }
}

```

注意：该点并未与红色圆形直接相交，而是与红色圆形的包围盒相交。

#### 像素碰撞检测

像素碰撞检测，是判断显示对象的图案（非透明区域）是否与一点相交。同样使用 `hitTestPoint()` 方法，用法为：

```js
var isHit:boolean = shp.hitTestPoint( x: number, y:number, true:boolean );
```

相比于矩形碰撞检测，增加了第三个参数 `true` ，表示要使用像素碰撞检测。

- 示例代码 1：

```js
var shp: egret.Shape = new egret.Shape();
shp.graphics.beginFill(0xff0000);
shp.graphics.drawRect(0, 0, 100, 100);
shp.graphics.endFill();
shp.width = 100;
shp.height = 100;
this.addChild(shp);
var isHit: boolean = shp.hitTestPoint(10, 10, true);
this.infoText.text = "isHit: " + isHit;
```

这段代码运行后效果与矩形碰撞检测的效果相同，如图：

- 示例代码 2：

```js
var shp: egret.Shape = new egret.Shape();
shp.graphics.beginFill(0xff0000);
shp.graphics.drawCircle(0, 0, 20);
shp.graphics.endFill();
shp.width = 100;
shp.height = 100;
this.addChild(shp);
var isHit: boolean = shp.hitTestPoint(25, 25, true);
this.infoText.text = "isHit: " + isHit;
```

文本中返回碰撞的结果，显示为 `false`，表示没有发生碰撞，与矩形碰撞检测的结果不同。

这是因为：矩形碰撞检测，是判断显示对象的包围盒是否与一点相交；而像素碰撞检测，是判断显示对象的图案（非透明区域）是否与一点相交。

大量使用像素碰撞检测，会消耗更多的性能

### 事件机制

#### 事件处理机制

Egret 中的事件机制是一套业内标准的事件处理架构。所提供的事件模式也非常的清晰、强大和高效。

在 Egret 中，事件模型定义了一套标准的生成和处理事件消息的方法，使程序中的对象可以相互交互，通信，保持自身状态和相应变化。**简单的说，数据的提供者只管发出数据对象，只要确保数据对象是 `egret.Event` 类或者子类的实例即可。这种数据对象 ，称为`事件（Event）`。数据对象的发出者，称之为事件`发送者（Event dispatcher）`。同时，接受事件的对象，称为 `事件侦听者（Event listener)`。**

#### 事件的执行流程

事件机制包含 4 个步骤：**注册侦听器，发送事件，侦听事件，移除侦听器**。这四个步骤是按照顺序来执行的。

注册侦听器，即指定事件由哪个对象的哪个方法来接受。在上一节约会的例子中，我们指定由男朋友来发送事件，由女朋友来接受事件。

只有在注册侦听器后，发送的事件才能被侦听。而且发送的事件必须和侦听器事件的类型匹配。在发送事件后，侦听器才能侦听到事件。

下面通过实例展示“约会”这个事件发送过程，以及代码编写过程。

**文档类**

```js
class SampleDate extends egret.DisplayObjectContainer
{
    public constructor()
    {
        super();
        //创建一个男朋友
        var boy:Boy = new Boy();
        boy.name = "男朋友";
        //创建一个女朋友
        var girl:Girl = new Girl();
        girl.name = "女朋友";
        //注册侦听器
        boy.addEventListener(DateEvent.DATE,girl.getDate,girl);
        //男朋友发送要求
        boy.order();
        //约会邀请完成后，移除侦听器
        boy.removeEventListener(DateEvent.DATE,girl.getDate,girl);
    }
}

```

**男朋友类**

```js
class Boy extends egret.Sprite
{
    public constructor()
    {
        super();
    }
    public order()
    {
        //生成约会事件对象
        var daterEvent:DateEvent = new DateEvent(DateEvent.DATE);
        //添加对应的约会信息
        daterEvent._year = 2014;
        daterEvent._month = 8;
        daterEvent._date = 2;
        daterEvent._where = "肯德基";
        daterEvent._todo = "共进晚餐";
        //发送要求事件
        this.dispatchEvent(daterEvent);
    }
}
```

**女朋友类**

```js
class Girl extends egret.Sprite
{
    public constructor()
    {
        super();
    }
    public getDate(evt:DateEvent)
    {
        console.log("得到了" + evt.target.name + "的邀请！" );
        console.log("会在" + evt._year + "年" + evt._month + "月" + evt._date + "日，在"+ evt._where+ evt._todo);
    }
}
```

**约会事件类**

```js
class DateEvent extends egret.Event
{
    public static DATE:string = "约会";
    public _year:number = 0;
    public _month:number = 0;
    public _date:number = 0;
    public _where:string = "";
    public _todo:string = "";
    public constructor(type:string, bubbles:boolean=false, cancelable:boolean=false)
    {
        super(type,bubbles,cancelable);
    }
}

```

#### Event 类

Event 类是所有事件类的基类。当创建一个自定义事件的时候，事件应该继承自 Event 类。同时 Event 类也包含一些事件。这些事件通常与显示列表，显示对象的状态有关。

在使用 Event 类时，有以下几个属性与方法需要注意。

- 首先是构造函数中的三个参数，`type`、`bubbles`和`cancelable`。
  - `type`指定事件的类型，在“约会”的例子中，`type`事件类型为“DATE”。我们经常使用的事件类型有“ADDED”、“COMPLETE”等。
  - `bubbles`是指定事件是否参与事件流的冒泡阶段，关于事件流，会在后面的小节中介绍。
  - `cancelable`表示是否可以取消与事件关联的默认动作。
- 另外还需要关注的属性是`target`，这个属性表示事件的目标，也就是事件的发送者。其他的一些方法都与事件流有关，后面的内容会进行详细介绍。

**自定义事件**

通常情况下，游戏中都会编写一些自定义事件，在上一小节中，已经编写过一个“约会”的自定义事件了，下面是详细代码。

```js
class DateEvent extends egret.Event
{
    public static DATE:string = "约会";
    public _year:number = 0;
    public _month:number = 0;
    public _date:number = 0;
    public _where:string = "";
    public _todo:string = "";
    public constructor(type:string, bubbles:boolean=false, cancelable:boolean=false)
    {
        super(type,bubbles,cancelable);
    }
}
```

上述自定义事件类`DateEvent`继承自 `egret.Event` 类。同时定义一个名称为 `DATE` 的属性，该属性为静态属性，类型为字符串。

上述自定义事件定义了一些事件中所需要的数据，这些数据包括日期，地点，做什么。在自定义事件类的时候，开发者可以根据自己的需要来定义事件类型和事件数据。

**事件侦听器**

事件侦听器也就是事件的处理者，负责接收事件携带的信息，并在接收到该事件后执行特定的代码。

Egret 中，事件的侦听器必须是一个函数。事件的发送者必须是 `egret.EventDispatcher` 类或者子类的实例。只有事件发送者才能侦听事件，并且可以注册侦听器。

侦听事件分为两个部分，第一是建立侦听器，侦听器可以是独立的函数，也可以是某一个对象的方法。第二步是注册侦听器，使用事件发送者的 `addEventListener()` 将相应的事件分配给侦听器。

下面是注册侦听函数的定义。

```typescript
public addEventListener(type:string, listener:Function, thisObject:any, useCapture:boolean = false, priority:number = 0)
```

- `type`：事件类型，必选。
- `listener`：用来处理事件的侦听器，必选。
- `thisObject`：作用域，必选，一般填写 this。因为 TypeScript 与 JavaScript 的 this 作用域不同，其 this 指向也会不同。如果不填写 this 的话，那么编译后的代码会发生错误。 关于 this 的问题，可以学习 JavaScript 中的原型链。
- `useCapture`: 确定侦听器是运行于捕获阶段还是运行于冒泡阶段，可选。设置为 true，则侦听器只在捕获阶段处理事件，而不在冒泡阶段处理事件。设置为 false，则侦听器只在冒泡阶段处理事件。
- `priority`： 事件侦听器的优先级，可选。优先级由一个带符号的整数指定。数字越大，优先级越高。优先级为 n 的所有侦听器会在优先级为 n -1 的侦听器之前得到处理。如果两个或更多个侦听器共享相同的优先级，则按照它们的添加顺序进行处理。默认优先级为 0。

##### 1.创建侦听器

侦听器必须是函数，它可以是一个独立函数，也可以是一个实例的方法。侦听器必须有一个参数，并且这个参数必须是 Event 类实例或其子类的实例， 同时，侦听器的返回值必须为空（void）。范例代码如下：

```js
listenerName(evt:Event):void {...}
```

##### 2.注册侦听器与移除侦听器

只有事件的发送者才可以注册侦听器，事件的发送者必须是 `EventDispatcher` 类或其子类的实例。移除侦听器也同理，通常情况下，注册侦听器与移除侦听器都是成对出现。

注册侦听器

```js
事件发送者.addEventListener(事件类型, 侦听器, this);
```

移除侦听器

```js
事件发送者.removeEventListener(事件类型, 侦听器, this);
```

##### 3.检测侦听器

如果需要在逻辑中检测某一个事件发送者是否注册了侦听器，有两个方法可以使用。 一个是 `hasEventListener` ,另外一个是 `willTrigger` 。两个方法执行效果相同，都是判断一个事件发送者是否注册了某一个类型的事件。

如果该事件类型已经被注册过，返回 `true`，如果没有被注册过，返回 `false`。

```js
事件发送者.hasEventListener(事件类型);
```

##### 4.TouchEvent 的启动开关

TouchEvent 的启动开关 `touchEnabled` 指定此对象是否接收触摸或其他用户输入。默认值为 false，实例将不接收任何触摸事件（或其他用户输入事件）。如果将 `touchEnabled`设置为 true，则显示对象实例将会接收触摸事件或其他用户输入事件。要更改显示对象的所有子级的 touchEnabled 行为，请使用 `DisplayObjectContainer.touchChildren`。

实际使用过程，如果某些显示对象需要侦听 TouchEvent，请先打开：

```js
显示对象实例.touchEnabled = true;
```

#### 事件的优先级

通过制定事件的优先级来设置事件侦听器的执行顺序。

可以在注册侦听器的时候制定事件的优先级。

```js
public addEventListener(type:string, listener:Function, thisObject:any, useCapture:boolean = false, priority:number = 0)
```

制定优先级需要设置 `priority` 属性。该属性为一个 number 类型，当数字越大，则优先级越大。在触发事件的时候优先级越高，越先执行。

#### 触摸事件

对于移动游戏，触摸事件是最常用的用户交互事件类型。Egret 为触摸事件设置了专门的触摸事件类`egret.TouchEvent`。

其包含的事件类型主要有：

- TOUCH_BEGIN：当用户第一次触摸启用触摸的设备时（例如，用手指触摸配有触摸屏的移动电话或平板电脑）触发
- TOUCH_CANCEL：由于某个事件取消了触摸时触发
- TOUCH_END：当用户移除与启用触摸的设备的接触时（例如，将手指从配有触摸屏的移动电话或平板电脑上抬起）触发
- TOUCH_MOVE：当用户触碰设备并移动时进行触发，而且会连续触发，直到接触点被删除
- TOUCH_TAP：当用户在触摸设备上与开始触摸的同一 DisplayObject 实例上抬起接触点时触发（相当与点击事件）

在 Egret 中使用触摸事件时，需要打开显示对象的触摸事件开关，即将该显示对象的`touchEnabled`属性设置为`true`。代码示例如下：

```js
class TouchEventTest extends egret.DisplayObjectContainer
{
    public constructor()
    {
        super();
        this.addEventListener(egret.Event.ADDED_TO_STAGE,this.onAddToStage,this);
    }
    private onAddToStage(event:egret.Event)
    {
        //添加显示文本
        this.drawText();
        //绘制一个透明度为1的绿色矩形，宽高为100*80
        var spr1:egret.Sprite = new egret.Sprite();
        spr1.graphics.beginFill(0x00ff00, 1);
        spr1.graphics.drawRect(0, 0, 100, 80);
        spr1.graphics.endFill();
        spr1.width = 100;
        spr1.height = 80;
        this.addChild( spr1 );
        //设置显示对象可以相应触摸事件
        spr1.touchEnabled = true;
        //注册事件
        spr1.addEventListener( egret.TouchEvent.TOUCH_TAP, this.onTouch, this );
        this.addEventListener(egret.TouchEvent.TOUCH_TAP, this.onTouchTap, this);
        this.addEventListener(egret.TouchEvent.TOUCH_TAP, this.onTouchTaps, this, true);
    }
    private onTouch( evt:egret.TouchEvent )
    {
        this.txt.text += "\n点击了spr1";
    }
    private onTouchTap( evt:egret.TouchEvent )
    {
        this.txt.text += "\n容器冒泡侦听\n---------";
    }
    private onTouchTaps( evt:egret.TouchEvent )
    {
        this.txt.text += "\n容器捕获侦听";
    }
    //绘制文本
    private  txt:egret.TextField;
    private drawText():void
    {
        this.txt = new egret.TextField();
        this.txt.size = 12;
        this.txt.x = 250;
        this.txt.width = 200;
        this.txt.height = 200;
        this.txt.text = "事件文字";
        this.addChild( this.txt );
    }
}
```

### 发送 http 请求

Egret 中封装了 `XMLHttpRequest` 进行异步的数据交互。

#### GET 方法

GET 方法是 HTTP 　请求的默认方法，数据经过简单的编码发送出去，并作为 URL 的一部分发送到服务器。由于浏览器对 URL 长度的限制，提交的数据长度也有限制。

#### POST 方法

POST 方法克服了 GET 方法的一些缺点，可以发送较大的数据.数据也不再是明文发送的。出于安全的考虑一般选用 POST 方法。 POST 提交的数据也可以从标准输入输出流中获取。

#### 发送请求

```js
var request = new egret.HttpRequest();
request.responseType = egret.HttpResponseType.TEXT;
request.open("http://httpbin.org/get", egret.HttpMethod.GET);
request.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
request.send();
// 回调函数的绑定和浏览器有些区别
request.addEventListener(egret.Event.COMPLETE, this.onGetComplete, this);
request.addEventListener(egret.IOErrorEvent.IO_ERROR, this.onGetIOError, this);
request.addEventListener(egret.ProgressEvent.PROGRESS, this.onGetProgress, this);
```

上面发送了一个 GET 请求到`http://httpbin.org/get`，然后添加回调事件，当请求成功或者失败之后来获取数据。

通过`COMPLETE`事件的`response`属性可获取到返回的信息。通过 `ProgressEvent` 事件的`bytesLoaded`和`bytesTotal`获取可加载进度。回调函数代码如下：

```typescript
private onGetComplete(event:egret.Event):void {
    var request = <egret.HttpRequest>event.currentTarget;
    console.log("get data : ",request.response);
    var responseLabel = new egret.TextField();
    responseLabel.size = 18;
    responseLabel.text = "GET response: \n" + request.response.substring(0, 50) + "...";
    this.addChild(responseLabel);
    responseLabel.x = 50;
    responseLabel.y = 70;
}
private onGetIOError(event:egret.IOErrorEvent):void {
    console.log("get error : " + event);
}
private onGetProgress(event:egret.ProgressEvent):void {
    console.log("get progress : " + Math.floor(100*event.bytesLoaded/event.bytesTotal) + "%");
}
```

发送 POST 请求的代码如下:

```js
var request = new egret.HttpRequest();
request.responseType = egret.HttpResponseType.TEXT;
//设置为 POST 请求
request.open("http://httpbin.org/post", egret.HttpMethod.POST);
request.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
request.send();
request.addEventListener(egret.Event.COMPLETE, this.onPostComplete, this);
request.addEventListener(egret.IOErrorEvent.IO_ERROR, this.onPostIOError, this);
request.addEventListener(egret.ProgressEvent.PROGRESS, this.onPostProgress, this);
```

添加回调函数：

```js
private onPostComplete(event:egret.Event):void {
    var request = <egret.HttpRequest>event.currentTarget;
    console.log("post data : ",request.response);
    var responseLabel = new egret.TextField();
    responseLabel.size = 18;
    responseLabel.text = "POST response:\n" + request.response.substring(0, 50) + "...";
    this.addChild(responseLabel);
    responseLabel.x = 300;
    responseLabel.y = 70;
}
private onPostIOError(event:egret.IOErrorEvent):void {
    console.log("post error : " + event);
}
private onPostProgress(event:egret.ProgressEvent):void {
    console.log("post progress : " + Math.floor(100*event.bytesLoaded/event.bytesTotal) + "%");
}
```

#### 发送带参数的请求

上面我们发送了一段空的请求到服务端，实际使用过程中一般都需要发送带参数的请求到服务端。

发送数据的格式：在 HTTP 客户端发送的数据，一般以`key`和`value`的形式组成，多个数据之间用`&`相连。拼接之后形成如下的形式:

```js
key1=value1&key2=valueP2
```

通过 GET 方法发送的参数会加到 URL 的后面拼接起来，并以`?`分隔。POST 方法发送的参数需要先设置 HTTP 请求的头信息，告诉服务端是以什么样的形式来发送的数据。我们最常用的就是`application/x-www-form-urlencoded`,表示我们以`key`和`value`方式来格式化参数。服务端也可以用同样的方法来取到参数。

发送 POST 请求. 需要注意的是发送 POST 请求需要将参数放到`send`方法的参数中发送出去。并且要设置其响应头，在我们的例子中使用`key` `value` 的方式来格式化参数，这里需要设置响应头`Content-Type`为`application/x-www-form-urlencoded`。修改上面 POST 请求相应代码如下:

```js
//拼接参数
var params = "p1=postP1&p2=postP2";
var request = new egret.HttpRequest();
request.responseType = egret.HttpResponseType.TEXT;
request.open("php/post_test.php", egret.HttpMethod.POST);
//设置响应头
request.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
//发送参数 post
request.send(params);
// 发送参数 get, 通过url传递
request.send();
```

#### 加载位图文件

Egret 提供了 `ImageLoader` 类，用于加载位图文件。

例如 `ImageLoader` 类通过如下代码加载位于 ‘resource/egret.png’ 的图片：

```js
var imgLoader: egret.ImageLoader = new egret.ImageLoader();
imgLoader.once(egret.Event.COMPLETE, this.imgLoadHandler, this);
imgLoader.load("resource/assets/bg.jpg");
```

在所定义的回调事件中，可以用下面的方式获取该图片对应的 BitmapData，并以此来创建位图：

```js
imgLoadHandler( evt:egret.Event ):void{
    let loader:egret.ImageLoader = evt.currentTarget;
    let bmd:egret.BitmapData = loader.data;
    //创建纹理对象
    let texture = new egret.Texture();
    texture.bitmapData = bmd;
    let bmp:egret.Bitmap = new egret.Bitmap(texture);
    this.addChild(bmp);
}
```

### 位图纹理

位图的使用需要纹理的支持，在 Egret 中，默认隐藏了纹理的操作，所有操作均针对于显示对象进行。但位图的显示依然基于纹理。在显示一张图片时， 需要使用 `Bitmap` 类，这是 egret 中的图片类，而纹理则来自于所加载的资源图片。通常情况下，用单张图片作为纹理，游戏中也会大量使用纹理集来进行渲染。

使用 `Bitmap` 类创建图片对象，代码如下：

```js
var img: egret.Bitmap = new egret.Bitmap();
```

此时得到一个位图对象，将它添加到显示列表中，还不会看到任何内容。因为该位图对象仅仅是一个“空对象”，还没有为它指定任何的纹理。

给该位图对象指定一个纹理，在画面中显示出渲染的文件。

指定纹理的方式是设置 `Bitmap` 中的 `texture` 属性。

```js
var img: egret.Bitmap = new egret.Bitmap();
img.texture = RES.getRes("bg_jpg");
this.addChild(img);
```

#### 资源配置

上面一行代码为位图添加纹理，它有一个输入参数：”图片 ID”。

所有加载的资源都会有一个唯一 ID，这个 ID 绝大部分取自图片文件名称，也有一些资源会定义一些其他的 ID。这些图片的组织方式都是由一个 json 文件描述的。

下面是一个标准的资源配置文件：

```js
{
    "resources":
    [
        {"name":"bgImage","type":"image","url":"assets/bg.jpg"},
        {"name":"egretIcon","type":"image","url":"assets/egret_icon.png"},
        {"name":"description","type":"json","url":"config/description.json"}
    ],
    "groups":
    [
        {"name":"preload","keys":"bgImage,egretIcon"}
    ]
}
```

在一个 json 资源配置文件中，应该包含两大部分，一个是组，另一个是资源。

#### 加载 base64 图片

```js
let str64 = "iVBORw0KGgoAAAANSUhEUgAAAHM...";
egret.BitmapData.create("base64", str64, (bitmapData) => {
  let texture = new egret.Texture();
  texture.bitmapData = bitmapData;
  let bmp = new egret.Bitmap(texture);
  this.addChild(bmp);
});
```

#### 九宫格

通常情况下为了游戏画面中的美观程度，会使用一些圆角矩形或者边缘不规则的矩形。 在游戏中，经常会对这些图形进行拉伸，那么拉伸后的图形会发生变形。为了让边缘不会因为拉伸而变形，可以使用“九宫格”。

下图是一个圆角矩形

![Egret](/public/images/egret/1-22.png)

将这个圆角矩形横向拉伸，边缘的拉伸变化如下图：

![Egret](/public/images/egret/1-23.png)

上面的效果不符合要求，会影响美观。希望无论图片如何拉伸，圆角始终不会变形，如下图。

![Egret](/public/images/egret/1-24.png)
九宫格系统可以实现上述效果。

![Egret](/public/images/egret/1-25.png)

上图中，用四条虚线将圆角矩形分割为 9 个区域，其中四个区域(图中区域编号 1，3，7，9)包含了圆角矩形的四个圆角。拉伸图像时，1，3，7，9 区域不拉伸，2，8 区域仅横向拉伸，4，6 区域仅纵向拉伸，5 区域横向纵向都拉伸。

设置九宫格的属性是 `Bitmap` 类中的 `scale9Grid` 属性。

下面是一个完整的示例代码，这个示例中，放置两个 `Bitmap` 对象，两个 `Bitmap` 对象都将 width 设置为原来的 2 倍。其中一个添加九宫格数据，另外一个不添加九宫格数据。

```js
var img: egret.Bitmap = new egret.Bitmap();
img.texture = RES.getRes("grid_png");
img.width *= 2;
this.addChild(img);

var img2: egret.Bitmap = new egret.Bitmap();
img2.texture = RES.getRes("grid_png");
var rect: egret.Rectangle = new egret.Rectangle(30, 31, 40, 41);
img2.scale9Grid = rect;
img2.width *= 2;
img2.y = 150;
// img2.y = 150;
this.addChild(img2);
```

上面的代码中，创建了一个类型为 `Rectangle` 的对象。该对象用来存放九宫格数据。初始化时填入了四个参数。

- 30：区域 1 的宽度值。
- 31：区域 1 的高度值
- 40：区域 2 的宽度值
- 41：区域 4 的高度值

官方 Demo 地址： [http://developer.egret.com/cn/example/egret2d/index.html#050-bitmap-prac-9grid](http://developer.egret.com/cn/example/egret2d/index.html#050-bitmap-prac-9grid)

#### 纹理的填充方式

位图的填充方式有两种，

- 拉伸图像以填充区域
- 重复图像以填充区域

**拉伸图像以填充区域**

创建 `Bitmap` 对象时会默认选择第一种填充方式。

下面是的示例中，使用默认填充方式。使用的纹理图片为一张 100\*100 的图片。图像宽度设置为 2 倍，高度设置为 3 倍。

```js
class BitmapTest extends egret.DisplayObjectContainer{
    public constructor()
    {
        super();
        this.addEventListener(egret.Event.ADDED_TO_STAGE,this.onAddToStage,this);
    }
    private onAddToStage(event:egret.Event) {
        RES.addEventListener(RES.ResourceEvent.GROUP_COMPLETE, this.onGroupComp, this);
        RES.loadConfig("resource/resource.json", "resource/");
        RES.loadGroup("preload");
    }
    private onGroupComp()
    {
        var img:egret.Bitmap = new egret.Bitmap();
        img.texture = RES.getRes("box");
        img.width *= 2;
        img.height *= 3;
        this.addChild(img);
    }
}
```

**重复图像以填充区域**

设置填充方法需要改变 `Bitmap` 中的 `fillMode` 属性。

```js
img.fillMode = egret.BitmapFillMode.REPEAT;
```

具体示例代码如下：

```js
class BitmapTest extends egret.DisplayObjectContainer{
    public constructor()
    {
        super();
        this.addEventListener(egret.Event.ADDED_TO_STAGE,this.onAddToStage,this);
    }
    private onAddToStage(event:egret.Event) {
        RES.addEventListener(RES.ResourceEvent.GROUP_COMPLETE, this.onGroupComp, this);
        RES.loadConfig("resource/resource.json", "resource/");
        RES.loadGroup("preload");
    }
    private onGroupComp()
    {
        var img:egret.Bitmap = new egret.Bitmap();
        img.texture = RES.getRes("box");
        img.fillMode = egret.BitmapFillMode.REPEAT;
        img.width *= 2;
        img.height *= 3;
        this.addChild(img);
    }
}
```

#### 纹理集的使用

纹理集是将一些零碎的小图放到一张大图当中。**游戏中经常使用到纹理集。**

> 纹理集就是浏览器中经常使用的雪碧图

Egret 内置了纹理集的支持，在编写代码之前，需要先制作一张纹理集，具体使用的工具可以选择业内比较流行的 Texture Merger。

首先制作一张纹理集，拼合后的效果如下：

![Egret](/public/images/egret/1-26.png)

同时生成的对应的 json 文件如下：

```json
{
  "file": "dogs.png",
  "frames": {
    "dog1": {
      "x": 322,
      "y": 2,
      "w": 184,
      "h": 222,
      "offX": 0,
      "offY": 0,
      "sourceW": 184,
      "sourceH": 222
    },
    "dog2": {
      "x": 307,
      "y": 226,
      "w": 147,
      "h": 154,
      "offX": 0,
      "offY": 0,
      "sourceW": 147,
      "sourceH": 154
    },
    "dog3": {
      "x": 2,
      "y": 2,
      "w": 318,
      "h": 217,
      "offX": 0,
      "offY": 0,
      "sourceW": 318,
      "sourceH": 217
    },
    "dog4": {
      "x": 2,
      "y": 393,
      "w": 298,
      "h": 201,
      "offX": 0,
      "offY": 0,
      "sourceW": 298,
      "sourceH": 201
    },
    "dog5": {
      "x": 2,
      "y": 221,
      "w": 303,
      "h": 170,
      "offX": 0,
      "offY": 0,
      "sourceW": 303,
      "sourceH": 170
    },
    "dog6": {
      "x": 2,
      "y": 596,
      "w": 245,
      "h": 125,
      "offX": 0,
      "offY": 0,
      "sourceW": 245,
      "sourceH": 125
    }
  }
}
```

- 将资源文件拷贝到项目文件夹中的 `resource/assets/` 目录下，同时修改资源配置文件 `default.res.json` 。

资源配置文件内容如下：

```js
{
"resources":
    [
        {"name":"dogs","type":"sheet","url":"assets/dogs.json"}
    ],
"groups":
    [
        {"name":"preload","keys":"dogs"}
    ]
}
```

```js
class BitmapTest extends egret.DisplayObjectContainer{
    public constructor()
    {
        super();
        this.addEventListener(egret.Event.ADDED_TO_STAGE,this.onAddToStage,this);
    }
    private onAddToStage(event:egret.Event) {
        RES.addEventListener(RES.ResourceEvent.GROUP_COMPLETE, this.onGroupComplete, this);
        RES.loadConfig("resource/default.res.json", "resource/");
        RES.loadGroup("preload");
    }
    private onGroupComplete()
    {
        var txtr:egret.Texture = RES.getRes( "dogs#dog1" );
        var img:egret.Bitmap = new egret.Bitmap( txtr );
        this.addChild(img);
    }
}
```

注意其中一行：

```js
var txtr: egret.Texture = RES.getRes("dogs#dog1");
```

![Egret](/public/images/egret/1-27.png)

使用纹理集的好处:

- 第一个 在游戏中使用纹理集能够帮助你的游戏提高加载速度，从而减少你的带宽成本，更快速的 HTTP 加载时间。
- 第二个 在 webgl 模式下，能够进行硬件加速。这也就意味着 GPU 将处理图像和转化。这时使用了纹理集可以降低 GPU 渲染批次（Draw）来提升渲染性能，每个纹理都必须在绘制出几何体图像前与 GPU 连接在一起，并且特定的 GPU 都必须拥有一个特定数量的纹理槽，所以在抽样单位间进行纹理转化将需要花费大量的时间。而纹理集则能够通过让 GPU 将一个单一纹理绑定在图像驱动器上而减少转化所需要的额外开销，也就是减少少 Draw 的次数，而提升游戏的性能。

### 颜色效果

#### 混合模式

混合模式是指同一个显示容器中的两个显示对象重叠时，重叠区域如何呈现的方式，也就是两个显示对象的重叠区域像素如何混合产生结果像素。

**覆盖混合**

覆盖混合，表示为”normal”，该显示对象出现在背景前面。显示对象的像素值将覆盖背景的像素值。在显示对象为透明的区域，背景是可见的。

**通常不设置混合模式，默认就是覆盖混合。设置图片为覆盖模式的代码：**
`img.blendMode = egret.BlendMode.NORMAL;`

使用覆盖混合的效果

![Egret](/public/images/egret/1-28.png)

**叠加混合**

叠加混合，表示为”add” ：将显示对象的原色值添加到它的背景颜色中，上限值为 0xFF。此设置通常用于使两个对象间的加亮溶解产生动画效果。

设置图片为覆盖模式的代码：
`img.blendMode = egret.BlendMode.ADD;`

![Egret](/public/images/egret/1-29.png)

**擦拭混合**

擦除混合，表示为”erase” ：根据显示对象的 Alpha 值擦除背景。即不透明区域将被完全擦除。

设置图片为覆盖模式的代码：
`img.blendMode = egret.BlendMode.ERASE;`

![Egret](/public/images/egret/1-30.png)

#### 滤镜

使用 `GlowFilter` 类可以对显示对象应用发光效果。发光样式的选项包括内侧发光、外侧发光以及挖空模式。
这里创建一个函数用来对传入的显示对象用给定的参数进行发光滤镜处理。
在接下的示例代码中，要传给滤镜的参数，将首先以局部变量的方式定义，并把每个参数的含义在注释部分进行说明。然后将这些参数填充到滤镜的构造函数相应位置。注意，为了结构清晰便于理解代码，所定义的局部变量与滤镜的构造函数参数将一一对应，并且顺序也是完全一致的。

白鹭小鸟在程序中用一张位图表示：
`var img:egret.Bitmap;`

创建滤镜：

```js
var color: number = 0x33ccff; /// 光晕的颜色，十六进制，不包含透明度
var alpha: number = 0.8; /// 光晕的颜色透明度，是对 color 参数的透明度设定。有效值为 0.0 到 1.0。例如，0.8 设置透明度值为 80%。
var blurX: number = 35; /// 水平模糊量。有效值为 0 到 255.0（浮点）
var blurY: number = 35; /// 垂直模糊量。有效值为 0 到 255.0（浮点）
var strength: number = 2; /// 压印的强度，值越大，压印的颜色越深，而且发光与背景之间的对比度也越强。有效值为 0 到 255。暂未实现
var quality: number = egret.BitmapFilterQuality.HIGH; /// 应用滤镜的次数，建议用 BitmapFilterQuality 类的常量来体现
var inner: boolean = false; /// 指定发光是否为内侧发光，暂未实现
var knockout: boolean = false; /// 指定对象是否具有挖空效果，暂未实现
var glowFilter: egret.GlowFilter = new egret.GlowFilter(color, alpha, blurX, blurY, strength, quality, inner, knockout);
```

最后对位图对象应用发光滤镜：

```
img.filters = [ glowFilter ];
```

如图是使用滤镜前后的效果对比：

![Egret](/public/images/egret/1-31.png)

#### 颜色矩阵滤镜

ColorMatrixFilter–颜色矩阵滤镜(egret.ColorMatrixFilter) 在颗粒等级上提供更好的控制显示对象的颜色转换方式。ColorMatrixFilter 为 4 行 5 列的多维矩阵(20 个元素的数组)。下图为等效的矩阵。

![Egret](/public/images/egret/1-32.png)

下面是一个图片灰度化的示例。首先准备一张图片：

![Egret](/public/images/egret/1-33.png)

然后通过下面颜色转换矩阵代码添加一个“灰度化”的效果:

```js
var hero: egret.Bitmap = new egret.Bitmap();
hero.texture = RES.getRes("hero_png");
this.addChild(hero);
//颜色矩阵数组
var colorMatrix = [0.3, 0.6, 0, 0, 0, 0.3, 0.6, 0, 0, 0, 0.3, 0.6, 0, 0, 0, 0, 0, 0, 1, 0];
var colorFlilter = new egret.ColorMatrixFilter(colorMatrix);
hero.filters = [colorFlilter];
```

在上述示例中，首先新建了一个显示对象，然后新建了一个颜色转换矩阵 `ColorMatrixFilter`,并通过显示对象的 `filters` 属性来设置滤镜。显示对象的 `filters` 属性包含当前与显示对象关联的每个滤镜对象的索引数组。

实现效果的关键是颜色转换矩阵的设置。上面我们将每个颜色通道都乘相同的系数来实现灰度效果。

![Egret](/public/images/egret/1-34.png)

#### 矩阵数据说明

在上面例子中我们实现了灰度图的效果，下面介绍颜色矩阵的含义：

![Egret](/public/images/egret/1-35.png)

实际的颜色值由下面的公式决定：

```js
redResult = a[0] * srcR + a[1] * srcG + a[2] * srcB + a[3] * srcA + a[4];
greenResult = a[5] * srcR + a[6] * srcG + a[7] * srcB + a[8] * srcA + a[9];
blueResult = a[10] * srcR + a[11] * srcG + a[12] * srcB + a[13] * srcA + a[14];
alphaResult = a[15] * srcR + a[16] * srcG + a[17] * srcB + a[18] * srcA + a[19];
```

公式中 srcR、srcG、srcB、srcA 表示原始显示对象的像素值, a 是颜色矩阵。新的红绿蓝和 alpha 通道实际由颜色矩阵和原始图片的像素值同时决定。颜色矩阵中的 Off 可以直接设置偏移量加上相应的 R G B A 的值的乘积即为最终的颜色值。所以与原来完全相同的矩阵转换应该是下面这样的：

```js
var colorMatrix = [1, 0, 0, 0, 100, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0];
```

修改代码中的颜色矩阵数组，编译运行得到如下效果图：

![Egret](/public/images/egret/1-36.png)

> 需要注意的 R G B 通道对应的偏移量的值应该为 -255 ~ 255，Alpha 通道对应的偏移量取值范围为 -255 ~ 255.应避免传入除数字外其他类型的值，比如字符串等。

**绿色加倍**

如果想使绿色通道加倍,colorMatrix[6] 加倍即可：

```js
var colorMatrix = [1, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0];
```

![Egret](/public/images/egret/1-37.png)

**增加亮度**

增加亮度的最简单途径是给每个颜色值添加相同的偏移量。

```
var colorMatrix = [
    1,0,0,0,100,
    0,1,0,0,100,
    0,0,1,0,100,
    0,0,0,1,0
];
```

![Egret](/public/images/egret/1-38.png)

### 时间控制

#### Timer 计时器

假设有这样一个需求：游戏中设计一个倒计时功能，要求玩家在 30 秒内进行游戏操作，并达到一定要求方可过关。

在这个需求中，需要一个倒计时功能，在 Egret 中提供了计时器 `Timer` 来实现类似功能。

`Timer` 相关的有两个属性，三个方法和两个事件。

两个属性是 `delay` 与 `repeatCount` ,分别表示每次间隔的时间（以毫秒为单位）和执行的次数（如果次数为 0，则表示不停的执行）。

三个方法为 `start`, `reset` 和 `stop`。作用分别是开始计时，重新计时和暂停计时。

两个事件分别为 `TimerEvent.TIMER` 和 `TimerEvent.TIMER_COMPLETE` 。分别在计时过程中触发和计时结束后触发。

示例演示：

```js
class TimerDemo extends egret.DisplayObjectContainer
{
    public constructor()
    {
        super();
        //创建一个计时器对象
        var timer:egret.Timer = new egret.Timer(500,5);
        //注册事件侦听器
        timer.addEventListener(egret.TimerEvent.TIMER,this.timerFunc,this);
        timer.addEventListener(egret.TimerEvent.TIMER_COMPLETE,this.timerComFunc,this);
        //开始计时
        timer.start();
    }
    private timerFunc()
    {
        console.log("计时");
    }
    private timerComFunc()
    {
        console.log("计时结束");
    }
}

```

#### Ticker 心跳

`startTick`（停止对应`stopTick`）**全局函数将以 60 帧速率回调函数。**它与 `ENTER_FRAME` 事件不同。`ENTER_FRAME` 是每帧回调，改变帧率会改变回调速度；`startTick`是定时回调，改变帧率也不会影响回调速度。

> ticker 可以理解为浏览器中的 requestAnimationFrame

示例代码：

```js
class startTickerTest extends egret.DisplayObjectContainer {
    public constructor() {
        super();
        this.once(egret.Event.ADDED_TO_STAGE,this.onLoad,this);
    }
    private star:egret.Bitmap;
    private speed:number = 0.05;
    private time:number = 0;
    private onLoad(event:egret.Event) {
        var star:egret.Bitmap = new egret.Bitmap(RES.getRes("star"));
        this.addChild(star);
        this.star = star;
        this.time = egret.getTimer();
        egret.startTick(this.moveStar,this);
    }
    private moveStar(timeStamp:number):boolean {
        var now = timeStamp;
        var time = this.time;
        var pass = now - time;
        console.log("moveStar: ",(1000 / pass).toFixed(5));
        this.time = now;
        return false;
    }
}
```

`startTick` 函数有两个传入参数，第一个参数是回调函数，该回调函数要求有返回值，如果返回为`true`将在回调函数执行完成之后立即重绘，为`false`则不会重绘。第二个参数是`this`对象，通常传入`this`即可。

下面修改回调函数中的代码:

```js
private moveStar(timeStamp:number):boolean {
    var now = timeStamp;
    var time = this.time;
    var pass = now - time;
    console.log("moveStar: ",(1000 / pass).toFixed(5));
    this.star.x += this.speed * pass;
    if(this.star.x > 300)
        egret.stopTick(this.moveStar,this);
    this.time = now;
    return false;
}
```

#### 帧事件

帧事件 `ENTER_FRAME` **在下一帧开始时回调**。所以它的回调速率是跟帧率相关的。下面代码测试了不同帧率下的表现：

```js
class startTickerTest extends egret.DisplayObjectContainer {
    public constructor() {
        super();
        this.once(egret.Event.ADDED_TO_STAGE,this.onLoad,this);
    }
    private timeOnEnterFrame:number = 0;
    private onLoad(event:egret.Event) {
        this.addEventListener(egret.Event.ENTER_FRAME,this.onEnterFrame,this);
        this.timeOnEnterFrame = egret.getTimer();
    }
    private  onEnterFrame(e:egret.Event){
        var now = egret.getTimer();
        var time = this.timeOnEnterFrame;
        var pass = now - time;
        console.log("onEnterFrame: ", (1000 / pass).toFixed(5));
        this.timeOnEnterFrame = egret.getTimer();
    }
}

```

### 屏幕适配

根据不同的项目需求，可能需要不同的缩放模式。

Egret 目前支持的模式有：`showAll`, `noScale`, `noBorder`, `exactFit`, `fixedWidth`, `fixedHeight`, `fixedNarrow`, `fixedWide`。

缩放模式的设置方法有两种：

1.在 index.html 文件中修改 `data-scale-mode` 属性。

2.在项目代码中随时修改，修改方式如下：

```js
this.stage.scaleMode = egret.StageScaleMode.SHOW_ALL;
```

下面以一个图例说明各种缩放模式的含义。

该例用到一张 600\*600 的图片 emmad.jpg。该图原始显示效果：

![Egret](/public/images/egret/1-39.png)

在 index.html 文件中修改默认舞台大小为 600\*600：

```js
data-content-width="600"
data-content-height="600"
```

##### 1.1 showAll 模式

在 index.html 文件中设置 `data-scale-mode="showAll"`
或在项目代码中写

```js
this.stage.scaleMode = egret.StageScaleMode.SHOW_ALL;
```

showAll 模式原理图解：

![Egret](/public/images/egret/1-40.png)

showAll 模式是保持宽高比，显示全部内容。缩放后应用程序内容向较窄方向填满播放器窗口，另一个方向的两侧可能会不够宽而留有黑边。
在此模式下，舞台尺寸(stage.stageWidth,stage.stageHeight)始终等于初始化时外部传入的应用程序内容尺寸。

showAll 是一种常用模式。

##### 1.2 noScale 模式

在 index.html 文件中设置 `data-scale-mode="noScale"`
或在项目代码中写

```js
this.stage.scaleMode = egret.StageScaleMode.NO_SCALE;
```

noScale 模式原理图解：

![Egret](/public/images/egret/1-41.png)

noScale 模式是不对内容进行任何缩放，保持原始的 1:1 比例，然后直接把舞台对齐到浏览器的左上角。即使在更改播放器窗口大小时，它仍然保持不变。如果播放器窗口比内容小，则可能进行一些裁切。
在此模式下，舞台尺寸（stage.stageWidth,stage.stageHeight）始终跟播放器窗口大小保持一致。

##### 1.3 noBorder 模式

在 index.html 文件中设置 `data-scale-mode="noBorder"`
或在项目代码中写

```js
this.stage.scaleMode = egret.StageScaleMode.NO_BORDER;
```

noBorder 模式原理图解：

![Egret](/public/images/egret/1-42.png)

noBorder 模式会根据屏幕的尺寸等比缩放内容，缩放后应用程序内容向较宽方向填满播放器窗口，不会有黑边存在，另一个方向的两侧可能会超出播放器窗口而被裁切，只显示中间的部分。
在此模式下，舞台尺寸(stage.stageWidth,stage.stageHeight)始终等于初始化时外部传入的应用程序内容尺寸。

##### 1.4 exactFit 模式

在 index.html 文件中设置 `data-scale-mode="exactFit"`
或在项目代码中写

```js
this.stage.scaleMode = egret.StageScaleMode.EXACT_FIT;
```

exactFit 模式原理图解：

![Egret](/public/images/egret/1-43.png)

exactFit 模式是不保持原始宽高比缩放应用程序内容，缩放后应用程序内容正好填满播放器窗口。简单的说就是不按照原来内容的比例，直接拉伸，暴力填充整个屏幕。
在此模式下，舞台尺寸(stage.stageWidth,stage.stageHeight)始终等于初始化时外部传入的应用程序内容尺寸。

##### 1.5 fixedWidth 模式

在 index.html 文件中设置 `data-scale-mode="fixedWidth"`
或在项目代码中写

```js
this.stage.scaleMode = egret.StageScaleMode.fixedWidth;
```

fixedWidth 模式原理图解：

![Egret](/public/images/egret/1-44.png)

**fixedWidth 模式是保持原始宽高比缩放应用程序内容**，缩放后应用程序内容在水平和垂直方向都填满播放器窗口，但只保持应用程序内容的原始宽度不变，高度可能会改变。
在此模式下，舞台宽度(stage.stageWidth)始终等于初始化时外部传入的应用程序内容宽度。舞台高度(stage.stageHeight)由当前的缩放比例与播放器窗口高度决定。

##### 1.6 fixedHeight 模式

在 index.html 文件中设置 `data-scale-mode="fixedHeight"`
或在项目代码中写

```js
this.stage.scaleMode = egret.StageScaleMode.fixedHeight;
```

fixedHeight 模式原理图解：

![Egret](/public/images/egret/1-45.png)

fixedHeight 模式保持原始宽高比缩放应用程序内容，缩放后应用程序内容在水平和垂直方向都填满播放器窗口，但只保持应用程序内容的原始高度不变，宽度可能会改变。
在此模式下，舞台高度(stage.stageHeight)始终等于初始化时外部传入的应用程序内容高度。舞台宽度(stage.stageWidth)由当前的缩放比例与播放器窗口宽度决定。

##### 1.7 fixedNarrow 模式

在 index.html 文件中设置 `data-scale-mode="fixedNarrow"`
或在项目代码中写

```js
this.stage.scaleMode = egret.StageScaleMode.fixedNarrow;
```

**保持原始宽高比缩放应用程序内容**，缩放后应用程序内容在水平和垂直方向都填满播放器视口，**应用程序内容的较窄方向可能会不够宽而填充。**
在此模式下，舞台高度(Stage.stageHeight)和舞台宽度(Stage.stageWidth)由当前的缩放比例与播放器视口宽高决定。

##### 1.8 fixedWide 模式

在 index.html 文件中设置 `data-scale-mode="fixedWide"`
或在项目代码中写

```js
this.stage.scaleMode = egret.StageScaleMode.fixedWide;
```

**保持原始宽高比缩放应用程序内容**，缩放后应用程序内容在水平和垂直方向都填满播放器视口，**应用程序内容的较宽方向的两侧可能会超出播放器视口而被裁切。**
在此模式下，舞台高度(Stage.stageHeight)和舞台宽度(Stage.stageWidth)由当前的缩放比例与播放器视口宽高决定。
